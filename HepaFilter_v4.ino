/*******************************************************************************
   Arduino_GFX setting
   Arduino Nano, Micro and more: CS:  9, DC:  8, RST:  7, BL:  6
 ******************************************************************************/
#include <Arduino_GFX_Library.h>
//#include <EEPROM.h>
#include "PCF8574.h"
#include "FastLED.h"

//NeoPixle definations
#define NUM_LEDS 2
#define DATA_PIN 10
CRGB leds[NUM_LEDS];
#define LED_TYPE WS2812  // or the type of LEDs you are using
#define COLOR_ORDER RGB  // try GRB or BGR instead of RGB

#if defined(DISPLAY_DEV_KIT)
Arduino_GFX *gfx = create_default_Arduino_GFX();
#else /* !defined(DISPLAY_DEV_KIT) */

Arduino_DataBus *bus = create_default_Arduino_DataBus();

Arduino_GFX *gfx = new Arduino_GC9A01(bus, 7 /* RST */, 0 /* rotation */, true /* IPS */);
#endif /* !defined(DISPLAY_DEV_KIT) */

// Set i2c address
// PCF8574 pcf8574(0x20);
PCF8574 pcf8574(0x38);

// #define MOTOR_SPEED_PIN 5 // PCF8574 Pin P5


#define ZERO_DETECT_PIN 2       // the number of the zeroDetct pin.
#define PIN_PWM 3               // Motor PWM Pin
#define PIN_CURRENT_SENSE A3    // For Current Sensor

#define CHK_BTN_AUTO 1
#define CHK_BTN_SLEEP 2
#define CHK_BTN_ON_OFF 4
#define CHK_BTN_SPEED 32
#define CHK_BTN_TIMER 16

#define CIRCLE_RAD 115
#define TIM0_OVF 249     // Interrupt overflow count 1mSec
#define INCR 80

#define LED_FAN 12            // Blue
#define LED_AUTO_MODE 9//7      // Blue
#define LED_SLEEP 7//9          // Blue
#define LED_SPEED_LOW 11      // Blue
#define LED_SPEED_MED 10      // Blue
#define LED_SPEED_HIGH 8      // Blue
#define LED_SPEED_LOW_DIM 13  // For ledStatus
#define LED_SPEED_MED_DIM 14    // For ledStatus
#define LED_SPEED_HIGH_DIM 15   // For ledStatus

// For Sleep and Restore Functionality
#define NUM_LED_AUTO 512//128
#define NUM_LED_SPEED_HIGH 256
#define NUM_LED_SLEEP 128//512
#define NUM_LED_SPEED_MED 1024
#define NUM_LED_SPEED_LOW 2048
#define NUM_LED_FAN 4096
#define NUM_LED_SPEED_LOW_DIM 8192
#define NUM_LED_SPEED_MED_DIM 16384
#define NUM_LED_SPEED_HIGH_DIM 32768

#define SPEED_MULTIPLIER 2
#define MAX_FAN_SPEED 3
#define MAX_Sleep_Mode 2
#define MAX_HOURS 8
#define ONE_HOUR_COUNT 3516000//58600//3600000
#define DISP_OFF 0

#define MAX_COUNT_BREATH 30
#define MAX_BRIGHTNESS 255

#define PM25_LVL0_5_VAL 5    // AQI 0 – 5
#define PM25_LVL0_VAL 50    // AQI 6 – 50
#define PM25_LVL1_VAL 75   // AQI 51 – 75
#define PM25_LVL2_VAL 150   // AQI 76 – 150
#define PM25_LVL3_VAL 200   // AQI 151 – 200
#define PM25_LVL4_VAL 300   // AQI 201 – 300
#define PM25_LVL5_VAL 500   // AQI 301 – 500

#define MUSIC_PLAY_TIME 500  //mili seconds

#define CURRENT_SAMPLES 100
#define CURRENT_SAMPLES_F 100.0
#define CHANGE_HEPA_FILTER 360.0
#define HYSTERSIS_VALUE 50.0
#define CHECK_HEPA_FILTER_STATUS 10000 // time in milliSec

// Buttons variables
volatile bool isAutoPressed = false;
volatile bool isSleepPressed = false;
volatile bool isPowerPressed = false;
volatile bool isSpeedPressed = false;
volatile bool isTimerPressed = false;
volatile bool isAutoReleased = false;
volatile bool isSleepReleased = false;
volatile bool isPowerReleased = false;
volatile bool isSpeedReleased = false;
volatile bool isTimerReleased = false;

volatile int hoursCount = 0;
volatile long hoursCounter = 0;
unsigned char countTimerDisp = 0;
volatile unsigned char fanSpeed = 0;
volatile unsigned char SleepMode = 0;
unsigned char auto_fan_speed = 0;
volatile unsigned char pwmCount = 0;
volatile bool flagON = false;
volatile bool flagTimerSet = false;
#define STATE_POWER_OFF 0
#define STATE_POWER_ON 1
volatile unsigned char sysState = STATE_POWER_OFF;
volatile unsigned int autoEnableCounter = 0;
volatile bool isAuto = false;
volatile bool isLongPress = false;
volatile bool breathEffect = false;
volatile bool isTimer = false;
volatile bool isSleep = false;
#define AUTO_MAX_COUNTER 2000
uint16_t ledStatus = 0;

const unsigned char fan [] PROGMEM = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xfc, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0xf, 0xf8, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x3f, 0xf8, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xe0, 0x0, 0xf0, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xe0, 0x7, 0xfc, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xe0, 0xf, 0xfe, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xc0, 0x3f, 0xff, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xc0, 0x3f, 0xff, 0x80, 0x0,
  0x0, 0x0, 0xff, 0xc0, 0x7f, 0xff, 0xc0, 0x0,
  0x0, 0x0, 0xff, 0x80, 0x7f, 0xff, 0xc0, 0x0,
  0x0, 0x0, 0xff, 0x80, 0xff, 0xff, 0xe0, 0x0,
  0x1, 0x0, 0x7f, 0x80, 0xff, 0xff, 0xe0, 0x0,
  0x3, 0x80, 0x7f, 0xd1, 0xff, 0xff, 0xf0, 0x0,
  0x3, 0x80, 0x3f, 0xff, 0xff, 0xe0, 0x0, 0x0,
  0x7, 0x80, 0x3f, 0xff, 0xff, 0x0, 0x0, 0x0,
  0x7, 0xc0, 0x3f, 0xff, 0xfe, 0x0, 0x0, 0x0,
  0x7, 0xe0, 0x1f, 0xff, 0xfc, 0x0, 0x0, 0x0,
  0xf, 0xf0, 0xf, 0xff, 0xfc, 0x0, 0x0, 0x0,
  0xf, 0xf0, 0x1f, 0xff, 0xfc, 0x0, 0x0, 0x0,
  0xf, 0xfc, 0x1f, 0xff, 0xfe, 0x0, 0x0, 0x0,
  0xf, 0xfe, 0x3f, 0xff, 0xff, 0xfe, 0x0, 0x0,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0x3f, 0xfc, 0x0,
  0x0, 0x7, 0xff, 0xff, 0xfe, 0xf, 0xfc, 0x0,
  0x0, 0x0, 0x1f, 0xff, 0xfe, 0x7, 0xfc, 0x0,
  0x0, 0x0, 0xf, 0xff, 0xfc, 0x3, 0xfc, 0x0,
  0x0, 0x0, 0x7, 0xff, 0xfe, 0x1, 0xfe, 0x0,
  0x0, 0x0, 0xf, 0xff, 0xfe, 0x0, 0xf8, 0x0,
  0x0, 0x0, 0x1f, 0xff, 0xff, 0x0, 0xf8, 0x0,
  0x0, 0x0, 0x7f, 0xff, 0xff, 0x0, 0x70, 0x0,
  0x3, 0xf, 0xff, 0xf0, 0xff, 0x80, 0x70, 0x0,
  0x3, 0xff, 0xff, 0xe0, 0x7f, 0x80, 0x30, 0x0,
  0x1, 0xff, 0xff, 0xe0, 0x7f, 0x80, 0x20, 0x0,
  0x0, 0xff, 0xff, 0xc0, 0x7f, 0xc0, 0x0, 0x0,
  0x0, 0xff, 0xff, 0x80, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x7f, 0xff, 0x80, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x3f, 0xff, 0x0, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x1f, 0xfe, 0x0, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0xf, 0xfc, 0x1, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x7, 0xf0, 0x1, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x3, 0xc0, 0x3, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3, 0xff, 0x80, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x7, 0xfe, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xf, 0xf0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};

const unsigned char refresh [] PROGMEM = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x3, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x7, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x1f, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x7f, 0x0, 0x0, 0x0,
  0x0, 0x0, 0xff, 0x0, 0x0, 0x0,
  0x0, 0x3, 0xff, 0xe0, 0x0, 0x0,
  0x0, 0xf, 0xff, 0xfe, 0x0, 0x0,
  0x0, 0x1f, 0xff, 0xff, 0x0, 0x0,
  0x0, 0x1f, 0xff, 0xff, 0xc0, 0x0,
  0x0, 0xf, 0xff, 0xff, 0xe0, 0x0,
  0x0, 0x7, 0xff, 0xff, 0xf0, 0x0,
  0x0, 0x1, 0xff, 0xff, 0xf8, 0x0,
  0x0, 0x0, 0x7f, 0x3f, 0xfc, 0x0,
  0x1, 0x80, 0x1f, 0xf, 0xfc, 0x0,
  0x7, 0xe0, 0x7, 0x3, 0xfe, 0x0,
  0xf, 0xe0, 0x3, 0x1, 0xfe, 0x0,
  0xf, 0xe0, 0x0, 0x1, 0xff, 0x0,
  0x1f, 0xe0, 0x0, 0x1, 0xff, 0x0,
  0x1f, 0xe0, 0x0, 0x0, 0x7f, 0x80,
  0x1f, 0xe0, 0x0, 0x0, 0x7f, 0x80,
  0x3f, 0xc0, 0x0, 0x0, 0x3f, 0xc0,
  0x7f, 0xc0, 0x0, 0x0, 0x3f, 0xc0,
  0x7f, 0xc0, 0x0, 0x0, 0x3f, 0xc0,
  0x7f, 0x80, 0x0, 0x0, 0x1f, 0xc0,
  0x7f, 0x80, 0x0, 0x0, 0x3f, 0xc0,
  0x3f, 0x80, 0x0, 0x0, 0x3f, 0xc0,
  0x3f, 0x80, 0x0, 0x0, 0x3f, 0xc0,
  0x3f, 0xc0, 0x0, 0x0, 0x3f, 0xc0,
  0x1f, 0xc0, 0x0, 0x0, 0x3f, 0xc0,
  0x1f, 0xc0, 0x0, 0x0, 0x7f, 0x80,
  0x1f, 0xf0, 0x0, 0x0, 0x7f, 0x80,
  0x1f, 0xf0, 0x0, 0x0, 0xff, 0x0,
  0xf, 0xf8, 0x0, 0x1, 0xfe, 0x0,
  0xf, 0xf8, 0x0, 0x3, 0xfe, 0x0,
  0x7, 0xfe, 0x0, 0x7, 0xfe, 0x0,
  0x7, 0xff, 0x0, 0xf, 0xfc, 0x0,
  0x1, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x1, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x0, 0x7f, 0xff, 0xff, 0xe0, 0x0,
  0x0, 0x7f, 0xff, 0xff, 0xe0, 0x0,
  0x0, 0x1f, 0xff, 0xff, 0x80, 0x0,
  0x0, 0xf, 0xff, 0xfe, 0x0, 0x0,
  0x0, 0x3, 0xff, 0xf8, 0x0, 0x0,
  0x0, 0x0, 0x3f, 0xc0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};

const unsigned char sleepSign [] PROGMEM = {
  0x0, 0x18, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x38, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x78, 0x0, 0x0, 0x0, 0x0,
  0x0, 0xf0, 0x0, 0x0, 0x0, 0x0,
  0x1, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x1, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x3, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x7, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0xf, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0xf, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0x1f, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0x1f, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x3f, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x3f, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0xff, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0xff, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0xff, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xf0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xf0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xf8, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xfc, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xfc, 0x0, 0x0, 0x0, 0x0,
  0x3f, 0xfe, 0x0, 0x0, 0x0, 0x0,
  0x3f, 0xff, 0x0, 0x0, 0x0, 0x0,
  0x3f, 0xff, 0x80, 0x0, 0x0, 0x0,
  0x1f, 0xff, 0xc0, 0x0, 0x0, 0x0,
  0xf, 0xff, 0xf0, 0x0, 0x0, 0x0,
  0xf, 0xff, 0xf8, 0x0, 0x0, 0xc,
  0x7, 0xff, 0xfe, 0x0, 0x0, 0x3c,
  0x3, 0xff, 0xff, 0xc0, 0x0, 0xfc,
  0x1, 0xff, 0xff, 0xf8, 0xf, 0xf8,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xe0,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x1f, 0xff, 0xff, 0xff, 0x0,
  0x0, 0xf, 0xff, 0xff, 0xfc, 0x0,
  0x0, 0x3, 0xff, 0xff, 0xf0, 0x0,
  0x0, 0x0, 0xff, 0xff, 0xe0, 0x0,
  0x0, 0x0, 0x7f, 0xff, 0x80, 0x0,
  0x0, 0x0, 0x0, 0x88, 0x0, 0x0
};

const unsigned char wifi1 [] PROGMEM = {
  0x0, 0xf, 0xfe, 0x0, 0x0,
  0x0, 0x7f, 0xff, 0x0, 0x0,
  0x3, 0xff, 0xff, 0xe0, 0x0,
  0x7, 0xff, 0xff, 0xfc, 0x0,
  0x1f, 0xff, 0xff, 0xfe, 0x0,
  0x3f, 0xff, 0xff, 0xff, 0x80,
  0x7f, 0xff, 0xff, 0xff, 0xc0,
  0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xe0,
  0x7f, 0xff, 0xff, 0xff, 0xe0,
  0x7f, 0xff, 0xff, 0xff, 0xc0,
  0x3f, 0xff, 0xff, 0xff, 0x80,
  0x3f, 0xf0, 0x3, 0xff, 0x0,
  0x1f, 0xc0, 0x0, 0x7e, 0x0,
  0x1f, 0x80, 0x0, 0x3c, 0x0,
  0xf, 0x0, 0x0, 0x1c, 0x0,
  0x4, 0x0, 0x0, 0x0, 0x0
};

const unsigned char wifi2 [] PROGMEM = {
  0x0, 0x0, 0x7, 0xff, 0xf0, 0x0, 0x0,
  0x0, 0x0, 0x7f, 0xff, 0xff, 0x0, 0x0,
  0x0, 0x1, 0xff, 0xff, 0xff, 0x80, 0x0,
  0x0, 0xf, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x0, 0x1f, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x7f, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xfe,
  0xff, 0xff, 0xfc, 0x0, 0x1f, 0xff, 0xff,
  0x7f, 0xff, 0xc0, 0x0, 0x3, 0xff, 0xfe,
  0x3f, 0xff, 0x0, 0x0, 0x0, 0xff, 0xfe,
  0x1f, 0xfc, 0x0, 0x0, 0x0, 0x3f, 0xfc,
  0x1f, 0xf8, 0x0, 0x0, 0x0, 0xf, 0xf8,
  0xf, 0xf0, 0x0, 0x0, 0x0, 0x7, 0xf0,
  0x7, 0xe0, 0x0, 0x0, 0x0, 0x3, 0xe0,
  0x7, 0xc0, 0x0, 0x0, 0x0, 0x1, 0xe0,
  0x3, 0x80, 0x0, 0x0, 0x0, 0x0, 0x40
};

const unsigned char wifi3 [] PROGMEM = {
  0x0, 0x0, 0x0, 0x0, 0xf1, 0xf8, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0,
  0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0,
  0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0,
  0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0xf, 0xff, 0xff, 0xff, 0x0, 0x87, 0xff, 0xff, 0xff, 0x0,
  0x3f, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xc0,
  0x7f, 0xff, 0xff, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xf0,
  0x7f, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xf0,
  0x3f, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xe0,
  0x1f, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xe0,
  0x1f, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xc0,
  0xf, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x80,
  0x7, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0,
  0x7, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0,
  0x3, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0x0,
  0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0
};

const unsigned char leaf [] PROGMEM = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x78, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf8, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xf8, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xf8, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x1f, 0xff, 0xff, 0xff, 0xfe, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x1f, 0xff, 0xff, 0xff, 0xf8, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x7f, 0xff, 0xff, 0xfc, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0xff, 0xff, 0xff, 0xf0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x1, 0xff, 0xff, 0xff, 0xc0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x1, 0xff, 0xff, 0xff, 0x80, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x3, 0xff, 0xff, 0xfe, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x3, 0xff, 0xff, 0xfc, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x3, 0xff, 0xff, 0xf8, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x7, 0xff, 0xff, 0xf0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x7, 0xff, 0xff, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0xf, 0xff, 0xff, 0xc0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0xf, 0xff, 0xff, 0x80, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0xf, 0xff, 0xff, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x1f, 0xff, 0xfe, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x1f, 0xff, 0xfc, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x1f, 0xff, 0xf8, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x1f, 0xff, 0xf0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x3f, 0xff, 0xf0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x3f, 0xff, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x3f, 0xff, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x3f, 0xff, 0xc0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x3f, 0xff, 0x80, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x3f, 0xff, 0x80, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x7f, 0xff, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x7f, 0xff, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x7f, 0xfe, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x7f, 0xfe, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x7f, 0xfe, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x7f, 0xfc, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x7f, 0xfc, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x7f, 0xfc, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x7f, 0xf8, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0,
  0x7f, 0xf8, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0,
  0x7f, 0xf8, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0,
  0x7f, 0xf8, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0,
  0x7f, 0xf0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0,
  0x7f, 0xf0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0,
  0x7f, 0xf0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0,
  0x3f, 0xf0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0,
  0x3f, 0xf0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0,
  0x3f, 0xf0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0,
  0x3f, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0,
  0x3f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0,
  0x3f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0,
  0x1f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0,
  0x1f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0,
  0x1f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0,
  0x1f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0,
  0xf, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0,
  0xf, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0,
  0xf, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
  0xf, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0,
  0x7, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0,
  0x7, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0,
  0x7, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0,
  0x3, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0,
  0x3, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0,
  0x3, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0,
  0x1, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0,
  0x1, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x1, 0xe0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x0, 0xe0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0xe0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};

// 'Filter1', 50x50px
const unsigned char filter1 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x07,
  0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0xcf, 0xff, 0x00, 0x00, 0x01, 0xfc, 0x00, 0xc0,
  0x3f, 0xe0, 0x00, 0x07, 0xff, 0x0f, 0xfc, 0xf0, 0xf8, 0x00, 0x0f, 0x1f, 0xff, 0xff, 0xe0, 0x3c,
  0x00, 0x1c, 0x03, 0xf0, 0x03, 0xe0, 0x0e, 0x00, 0x1c, 0x07, 0x80, 0x00, 0x78, 0x0e, 0x00, 0x1f,
  0xff, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x3c, 0x03, 0xe0,
  0x01, 0xf0, 0x0f, 0x00, 0x3e, 0x00, 0xff, 0xff, 0xc0, 0x1f, 0x00, 0x3f, 0x80, 0x3f, 0xff, 0x00,
  0x7f, 0x00, 0x3d, 0xf8, 0x00, 0xc0, 0x07, 0xe7, 0x00, 0x3c, 0x7f, 0xc0, 0xc0, 0xff, 0x8f, 0x00,
  0x3e, 0x0f, 0xff, 0xff, 0xfc, 0x1f, 0x00, 0x3e, 0x00, 0x7f, 0xff, 0x80, 0x1f, 0x00, 0x3e, 0x00,
  0x00, 0x00, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0x00, 0x00,
  0x00, 0x1f, 0x00, 0x3e, 0x07, 0x00, 0x00, 0x38, 0x1f, 0x00, 0x3e, 0x0f, 0x80, 0x00, 0x7c, 0x1f,
  0x00, 0x3e, 0x0f, 0xe0, 0x01, 0xfc, 0x1f, 0x00, 0x3e, 0x03, 0xf0, 0x03, 0xf0, 0x1f, 0x00, 0x3e,
  0x01, 0xf8, 0x07, 0xe0, 0x1f, 0x00, 0x3e, 0x00, 0xfc, 0x0f, 0xc0, 0x1f, 0x00, 0x3e, 0x00, 0x7f,
  0x3f, 0x80, 0x1f, 0x00, 0x3e, 0x00, 0x1f, 0xfe, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0x0f, 0xfc, 0x00,
  0x1f, 0x00, 0x3e, 0x00, 0x07, 0xf8, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0x07, 0xf8, 0x00, 0x1f, 0x00,
  0x3e, 0x00, 0x0f, 0xfc, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0x1f, 0xfe, 0x00, 0x1f, 0x00, 0x3e, 0x00,
  0x3f, 0x3f, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0xfe, 0x1f, 0xc0, 0x1f, 0x00, 0x3e, 0x01, 0xf8, 0x07,
  0xe0, 0x1f, 0x00, 0x3e, 0x03, 0xf0, 0x03, 0xf0, 0x1f, 0x00, 0x3e, 0x07, 0xe0, 0x01, 0xf8, 0x1f,
  0x00, 0x3e, 0x0f, 0xc0, 0x00, 0xfc, 0x1f, 0x00, 0x1e, 0x07, 0x00, 0x00, 0x38, 0x1e, 0x00, 0x1e,
  0x02, 0x00, 0x00, 0x10, 0x1e, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0f, 0x00, 0x00,
  0x00, 0x00, 0x3c, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff,
  0xe0, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xf8, 0x00, 0x00,
  0x00, 0x01, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00
};

volatile bool flag_change_filter = false;
char buff[10];
unsigned char colorCount = 1;
unsigned char wifiCount = 0;
unsigned long currMillis, prevMillis;
volatile unsigned int msCount = 0;
volatile int secCount = 0;
volatile bool flag_dispCount = true;
volatile bool flag_bgChange = false;
uint16_t bgColor = RED;           // modify to change default background color
uint16_t NewbgColor;              // modify to change default background color
uint16_t foreColor = BLACK;         // modify to change default foreground color
uint16_t dimColor = NAVY;           // modify to change default dim color
uint8_t red, green, blue;

float AcsValueF = 0.0;

// Function declarations
void Enable_Timer0(void);
void dispSegment(int);

struct pms5003data {
  uint16_t framelen;
  uint16_t pm10_standard, pm25_standard, pm100_standard;
  uint16_t pm10_env, pm25_env, pm100_env;
  uint16_t particles_01um, particles_05um, particles_10um, particles_25um, particles_50um, particles_100um;
  uint16_t unused;
  uint16_t checksum;
};

uint16_t map_p01 = 10;
uint16_t map_p25 = 50;
struct pms5003data data;

//Interrupt Service Routine for PCINT1(PC0-PC4), Panel Buttons
ISR(PCINT1_vect) {
  // ON/OFF
  if (((PINC & CHK_BTN_ON_OFF) == CHK_BTN_ON_OFF) && !isPowerPressed) {
    isPowerPressed = true;
  } else if (((PINC & CHK_BTN_ON_OFF) == 0) && isPowerPressed) {
    isPowerReleased = true;         isPowerPressed = false;
  }
  if (sysState == STATE_POWER_ON) {
    // Auto
    if (((PINC & CHK_BTN_AUTO) == CHK_BTN_AUTO) && !isAutoPressed && !isAutoReleased && !isSleep) {
      isAutoPressed = true;
    } else if (((PINC & CHK_BTN_AUTO) == 0) && isAutoPressed) {
      isAutoReleased = true;          isAutoPressed = false;
    }
    // Sleep
    if (((PINC & CHK_BTN_SLEEP) == CHK_BTN_SLEEP) && !isSleepPressed && !isSleepReleased) {
      isSleepPressed = true;
    } else if (((PINC & CHK_BTN_SLEEP) == 0) && isSleepPressed) {
      isSleepReleased = true;         isSleepPressed = false;
    }

  }
}

//Interrupt Service Routine for PCINT3(PD4-PD5), Panel Buttons
ISR(PCINT2_vect) {
  if (sysState == STATE_POWER_ON && !isSleep) {
    // Speed
    if (((PIND & CHK_BTN_SPEED) == CHK_BTN_SPEED) && !isSpeedPressed && !isSpeedReleased && !isAuto) {
      isSpeedPressed = true;
    } else if (((PIND & CHK_BTN_SPEED) == 0) && isSpeedPressed) {
      isSpeedReleased = true;         isSpeedPressed = false;
    }
    // Timer
    if (((PIND & CHK_BTN_TIMER) == CHK_BTN_TIMER) && !isTimerPressed && !isTimerReleased) {
      isTimerPressed = true;
    } else if (((PIND & CHK_BTN_TIMER) == 0) && isTimerPressed) {
      isTimerReleased = true;         isTimerPressed = false;
    }
  }
}

// Timer0 ISR after every 1mSec
ISR(TIMER0_COMPA_vect) {
  if (flagON) { // For Motor Control Only
    pwmCount--;
    if (pwmCount <= 0) {
      digitalWrite(PIN_PWM, LOW);     flagON = false;
    }
//    else if (pwmCount <= fanSpeed * (1)) {
    else if (pwmCount == ((unsigned char)(floor(fanSpeed * 0.9)))) {
      digitalWrite(PIN_PWM, HIGH);

    }
    else {
      digitalWrite(PIN_PWM, LOW);
    }
  }

  if (sysState == STATE_POWER_ON) {
    if (flagTimerSet) {
      msCount++;
      if (msCount > 3000) {
        msCount = 0;
        flagTimerSet = false;
      }
    }
    if (isTimer) {
      hoursCounter--;
      if (hoursCounter < 1) {
        isPowerReleased = true;   isTimer = false;
      }
      /*if(!isSleep && ((hoursCounter % 10000) == 0)) {
        dispSegment((int)(ceil(float(hoursCounter)/float(ONE_HOUR_COUNT))));
        }*/
    }
    // --> Block modification needed
    if (isAutoPressed == true) {
      autoEnableCounter++;
      if (autoEnableCounter > AUTO_MAX_COUNTER && !isLongPress) {
        breathEffect = !breathEffect;
        if (breathEffect) {
          CRGB fadeColor = getFadeColor(calculateAQI(map_p25)); // Dynamically set the color based on AQI
          startFadeToColor(fadeColor);
        }
        isLongPress = true;
      }
    }
  }

  if (breathEffect == true) {
  }
}

CRGB currentTargetColor;
int fadeStep = 0;
const int fadeSteps = 300;
unsigned long lastUpdate = 0;
const int updateInterval = 11;
bool fadeActive = false;
const int minBrightness = 5;

void startFadeToColor(CRGB targetColor) {
    currentTargetColor = targetColor;
    fadeStep = 0;
    // fadeDirection = 1;  // Start with increasing brightness
    fadeActive = true;  // Activate the fade
    fill_solid(leds, NUM_LEDS, CRGB::Black); // Ensure LEDs are initially off
    FastLED.show();
}

// Non-blocking fade logic (call this in a loop or timer)
void handleFade() {
    if (!fadeActive) return;

    unsigned long currentTime = millis();
    if (currentTime - lastUpdate < updateInterval) return; // Wait for the next update interval
    lastUpdate = currentTime;

    // // Calculate brightness using a sine wave for smooth transitions
    // float angle = (2.0 * PI * fadeStep) / fadeSteps; // Map step to a sine wave angle
    // // int brightness = (sin(angle) * 122.5) + 132.5; // Map sine wave output to 0-255
    // int brightness = (sin(angle) + 1.0) * 127.5; // Map sine wave output to 0-255
    
    float angle = (2.0 * PI * fadeStep ) / fadeSteps; // Full sine wave cycle (0 to 2*PI)
    float brightnessValue = (sin(angle) + 1.0) / 2.0;  // Map sine wave (-1 to 1) to (0 to 1)
    // int brightness = brightnessValue * 255; // Map to 0 to 255 brightness range
    int brightness = (brightnessValue * (255 - minBrightness)) + minBrightness;
     // Adjust brightness range for deeper dimming
    // brightness = map(brightness, 0, 255, 0, 255); // Lower the maximum brightness to make it dim closer to black

    // Apply brightness to all LEDs
    fill_solid(leds, NUM_LEDS, currentTargetColor);
    for (int i = 0; i < NUM_LEDS; i++) {
        leds[i].nscale8(brightness);
    }
    FastLED.show();

    // Update fade step
    fadeStep++;
    if (fadeStep > fadeSteps) {
        fadeStep = 0; // Loop back to create continuous breathing
    }
}

// Function to apply gamma correction (optional)
uint8_t gammaCorrect(uint8_t value) {
    float gamma = 2.2; // Typical gamma correction value for LEDs
    return pow((float)value / 255.0, gamma) * 255.0;
}

// Use corrected color
CRGB correctedColor(uint8_t r, uint8_t g, uint8_t b) {
    return CRGB(gammaCorrect(r), gammaCorrect(g), gammaCorrect(b));
}

CRGB getFadeColor(int aqi) {
    if (aqi <= PM25_LVL0_5_VAL) {         // Clean Air PM25
        return CRGB(0, 0, 255);           // Blue
    } else if (aqi > PM25_LVL0_5_VAL && aqi <= PM25_LVL0_VAL) {
        return CRGB(255, 0, 0);           // Green
    } else if (aqi > PM25_LVL0_VAL && aqi <= PM25_LVL1_VAL) {
        return CRGB(255, 255, 0);         // Yellow
    } else if (aqi > PM25_LVL1_VAL && aqi <= PM25_LVL2_VAL) {
        return CRGB(165, 255, 0);         // Orange
    } else if (aqi > PM25_LVL2_VAL && aqi <= PM25_LVL3_VAL) {
        return CRGB(0, 255, 0);           // Red
    } else if (aqi > PM25_LVL3_VAL && aqi <= PM25_LVL4_VAL) {
        return correctedColor(200, 0, 200); // Purple
    } else if (aqi > PM25_LVL4_VAL && aqi <= PM25_LVL5_VAL) {
        return CRGB(0, 128, 0);           // Maroon
    } else if (aqi > PM25_LVL5_VAL) {
        return CRGB(0, 128, 0);           // Maroon
    }
    return CRGB::Black;                   // Default (optional)
}

void setup(void)
{
  //FastLED.addLeds<WS2812B, DATA_PIN>(leds, NUM_LEDS);
  FastLED.addLeds<LED_TYPE, DATA_PIN, COLOR_ORDER>(leds, NUM_LEDS);
  init_pcf();
  gfx->begin();

#ifdef DF_GFX_BL
  pinMode(DF_GFX_BL, OUTPUT);
  digitalWrite(DF_GFX_BL, LOW);
#endif
  offDisp();
  Serial.begin(9600);
  //  pcf8574.begin(); // Initialize the PCF8574
  //   pcf8574.pinMode(P5, OUTPUT);
  //   pcf8574.digitalWrite(P5, HIGH);


  // pcf8574.digitalWrite(MOTOR_SPEED_PIN, LOW); // Ensure it starts LOW
  pinMode(ZERO_DETECT_PIN, INPUT);  // initialize the zeroDetct pin as an input:
  pinMode(PIN_PWM, OUTPUT);  // initialize the PWM pin as an input:
  digitalWrite(PIN_PWM, LOW);
  cli(); // clear Global Interrupt
  attachInterrupt(digitalPinToInterrupt(ZERO_DETECT_PIN), zeroDetect_ISR, CHANGE);
  initButtons();
  Enable_Timer0();

  sei(); // Enable the Global Interrupts
  startFadeToColor(CRGB::Red);
}

unsigned int x = 0;
float AcsValue = 0.0, Samples = 0.0, AvgAcs = 0.0;
unsigned long prev_millis;
unsigned long lastZeroCrossTime = 0;  // For tracking zero-cross timing

void loop()
{
  if (breathEffect) {
    // Update fade color only if the target color changes
    static CRGB lastFadeColor = CRGB::Black; // Track the last color used for fading
    int currentAQI = calculateAQI(map_p25);  // Get the current AQI
    CRGB currentFadeColor = getFadeColor(currentAQI); // Get the target color based on AQI

    // Only start a new fade if the target color has changed
    if (currentFadeColor != lastFadeColor) {
        lastFadeColor = currentFadeColor;
        startFadeToColor(currentFadeColor);
    }

    handleFade();
}
  if ((millis() - prev_millis) > CHECK_HEPA_FILTER_STATUS)
  {
    Samples = 0; // Reset Samples before taking new readings
    for (int x = 0; x < CURRENT_SAMPLES; x++)
    { //Get 150 samples
      AcsValue = analogRead(PIN_CURRENT_SENSE);     //Read current sensor values
      Samples = Samples + AcsValue;  //Add samples together
      delay (3); // let ADC settle before next sample 3ms
    }
    AvgAcs = Samples / CURRENT_SAMPLES_F; //Taking Average of Samples

    //((AvgAcs * (5.0 / 1024.0)) is converitng the read voltage in 0-5 volts
    //2.5 is offset(I assumed that arduino is working on 5v so the viout at no current comes
    //out to be 2.5 which is out offset. If your arduino is working on different voltage than
    //you must change the offset according to the input voltage)
    //0.185v(185mV) is rise in output voltage when 1A current flows at input
    AcsValueF = (2.5 - (AvgAcs * (5.0 / 1024.0)) ) / 0.185;

    if (AvgAcs > CHANGE_HEPA_FILTER && !flag_change_filter)
    {
      flag_change_filter = true;
      //gfx->drawBitmap(20, 95, filter1, 50, 50, foreColor);
    }
    else if (AvgAcs < (CHANGE_HEPA_FILTER - HYSTERSIS_VALUE) && flag_change_filter)
    {
      flag_change_filter = false;
      //gfx->drawBitmap(20, 95, filter1, 50, 50, bgColor);
    }
    prev_millis = millis();

     //Serial.println(AcsValue);
     //Serial.println(AvgAcs);
     //Serial.print("Avg Current : ");
     //Serial.println(AvgAcs);      //Print the read current on Serial monitor
  }
  if (readPMSdata(&Serial) && sysState == STATE_POWER_ON && flagTimerSet == false)
  {
    countTimerDisp++;
    map_p01 = data.pm10_env;  //data.pm10_standard; //map(data.particles_01um, 0, 65535, 0, 1000);
    map_p25 = data.pm25_env;  //data.pm25_standard; //map(data.particles_25um, 0, 65535, 0, 1000);
    int aqi = calculateAQI(map_p25);

    if (countTimerDisp > 10)
    {
      countTimerDisp = 0;
      if (isTimer && !isSleep)
      {
        dispSegment((int)(ceil(float(hoursCounter) / float(ONE_HOUR_COUNT))));
      }
    }
    else
    {
      if (!isSleep){
      gfx->setCursor(70, 25);
      gfx->setTextColor(foreColor, bgColor);
      gfx->setTextSize(5);
      // sprintf(buff, "%3d", fanSpeed);
      sprintf(buff, "%3d", aqi);
      gfx->print(buff);
      }
    }

    if (aqi <= PM25_LVL0_5_VAL){ // Clean Air PM25
      NewbgColor = BLUE; // changed requirements
      if (!breathEffect && !isSleep) {
        fill_solid(leds, NUM_LEDS, CRGB(0, 0, 255));
        FastLED.show();
      }
    }
    else if (aqi > PM25_LVL0_5_VAL && aqi <= PM25_LVL0_VAL) { 
      NewbgColor = GREEN; // changed requirements
      if (!breathEffect && !isSleep) {
        fill_solid(leds, NUM_LEDS, CRGB(255, 0, 0));
        FastLED.show();
      }
    }
    else if (aqi > PM25_LVL0_VAL && aqi <= PM25_LVL1_VAL) {
      NewbgColor = YELLOW; // changed requirements
      if (!breathEffect && !isSleep) {
        fill_solid(leds, NUM_LEDS, CRGB(255, 255, 0));
        FastLED.show();
      }
    }
    else if (aqi > PM25_LVL1_VAL && aqi <= PM25_LVL2_VAL) {
      NewbgColor = ORANGE;
      if (!breathEffect && !isSleep) {
        fill_solid(leds, NUM_LEDS, CRGB(165, 255, 0));
        FastLED.show();
      }
    }
    else if (aqi > PM25_LVL2_VAL && aqi <= PM25_LVL3_VAL) {
      NewbgColor = RED;
      if (!breathEffect && !isSleep) {
        fill_solid(leds, NUM_LEDS, CRGB(0, 255, 0));
        FastLED.show();
      }
    }
    else if (aqi > PM25_LVL3_VAL && aqi <= PM25_LVL4_VAL) {
      NewbgColor = PURPLE;
      if (!breathEffect && !isSleep) {
        fill_solid(leds, NUM_LEDS, CRGB(128, 0, 128));
        FastLED.show();
      }
    }
    else if (aqi > PM25_LVL4_VAL && aqi <= PM25_LVL5_VAL) {
      NewbgColor = MAROON;
      if (!breathEffect && !isSleep) {
        fill_solid(leds, NUM_LEDS, CRGB(0, 128, 0));
        FastLED.show();
      }
    }
    else if (aqi > PM25_LVL5_VAL) {
      NewbgColor = MAROON;
      if (!breathEffect && !isSleep) {
        fill_solid(leds, NUM_LEDS, CRGB(0, 128, 0));
        FastLED.show();
      }
    }

    if (isAuto)
    {
      if(aqi <= 5)
        fanSpeed = 0;
      else if(aqi > 5 && aqi <= 25)
        fanSpeed = 1;
      else if(aqi > 25 && aqi <= 50)
        fanSpeed = 1;
      else if(aqi > 50 && aqi <= 75)
        fanSpeed = 2;
      else if(aqi > 75 && aqi <= 100)
        fanSpeed = 3;
      else if(aqi > 100)
        fanSpeed = 3;
        
      if (auto_fan_speed != fanSpeed)
      {
        set_LED_Speed(fanSpeed);
        auto_fan_speed = fanSpeed;
        // Change state based on the fanSpeed
        switch (fanSpeed) {
          case 0:
            pcf8574.digitalWrite(P5, HIGH);
            pcf8574.digitalWrite(P7, HIGH);
            break;
          case 1:
            pcf8574.digitalWrite(P5, HIGH);
            pcf8574.digitalWrite(P7, LOW);
            break;
          case 2:
            pcf8574.digitalWrite(P5, LOW);
            pcf8574.digitalWrite(P7, HIGH);
            break;
          case 3:
            pcf8574.digitalWrite(P5, LOW);
            pcf8574.digitalWrite(P7, LOW);
            break;
          default:
            // All pins remain HIGH (Fan OFF)
            pcf8574.digitalWrite(P5, HIGH);
            pcf8574.digitalWrite(P7, HIGH);
            break;
        }
      }      
    }
  }

  if (NewbgColor != bgColor)
  {
    bgColor = NewbgColor;
    onDisp();
    set_LED_Speed(fanSpeed);
    set_LED_Auto(isAuto); // added for bug fixing version 2.2
  }

  switch (sysState)
  {
    case STATE_POWER_OFF:
      {
        if (isPowerReleased) {  // Turn ON Power
          gfx->clearScreen();
          play_device_on();
#ifdef DF_GFX_BL
          digitalWrite(DF_GFX_BL, HIGH);
#endif
          gfx->fillScreen(WHITE);
          gfx->drawCircle(120, 120, CIRCLE_RAD, GREEN);
          gfx->drawCircle(120, 120, CIRCLE_RAD + 1, GREEN);
          gfx->drawCircle(120, 120, CIRCLE_RAD + 2, GREEN);
          gfx->drawCircle(120, 120, CIRCLE_RAD + 3, GREEN);
          gfx->drawBitmap(60, 60, leaf, 107, 122, GREEN);
          delay(3000);
          sysState = STATE_POWER_ON;
          fanSpeed = 1;
          onDisp();
          set_LED_Speed(fanSpeed);
          breathEffect = false;
          isPowerReleased = false;
          flag_change_filter = false;
          pcf8574.digitalWrite(P5, HIGH);
          pcf8574.digitalWrite(P7, LOW);
        }
        break;
      }
    case STATE_POWER_ON:
      {
        if (isPowerReleased) {  // Turn OFF Power
          play_device_off();
          // gfx->clearScreen();
          // gfx->fillScreen(BLACK);
          hoursCount = 0;
          hoursCounter = 0;
          offDisp();
          dispSegment(DISP_OFF);
          set_LED_Speed(0);
          isAuto = false;
          set_LED_Auto(isAuto);
          fanSpeed = 0;
          isSleep = false;
          breathEffect = false;
          sysState = STATE_POWER_OFF;
          pcf8574.digitalWrite(P5, HIGH);
          pcf8574.digitalWrite(P7, HIGH);
          gfx->clearScreen();
          gfx->fillScreen(BLACK);
          isPowerReleased = false;
        }
        if (isSpeedReleased) {
          fanSpeed = fanSpeed + 1;
          if (fanSpeed > MAX_FAN_SPEED)
            fanSpeed = 1;
          set_LED_Speed(fanSpeed);

          // Change state based on the fanSpeed
          switch (fanSpeed) {
              case 0:
                  pcf8574.digitalWrite(P5, HIGH);
                  pcf8574.digitalWrite(P7, HIGH);
                  break;
              case 1:
                  pcf8574.digitalWrite(P5, HIGH);
                  pcf8574.digitalWrite(P7, LOW);
                  break;
              case 2:
                  pcf8574.digitalWrite(P5, LOW);
                  pcf8574.digitalWrite(P7, HIGH);
                  break;
              case 3:
                  pcf8574.digitalWrite(P5, LOW);
                  pcf8574.digitalWrite(P7, LOW);
                  break;
              default:
                  // All pins remain HIGH (Fan OFF)
                  pcf8574.digitalWrite(P5, HIGH); // Medium speed
                  pcf8574.digitalWrite(P7, HIGH); // Low speed
                  break;
          }
          play_menu_up();
          // Reset the `isSpeedReleased` flag to wait for the next button press
          isSpeedReleased = false;
        }
        if (isTimerReleased) {
          isTimer = false;
          msCount = 0;
          flagTimerSet = true;
          hoursCount++;
          if (hoursCount > MAX_HOURS)
            hoursCount = 0;
          dispSegment(hoursCount);
          hoursCounter = hoursCount * ONE_HOUR_COUNT;
          if (hoursCounter == 0)
            dispSegment(DISP_OFF);
          else
            isTimer = true;
          isTimerReleased = false;
          play_menu_up();
        }
        if (isAutoReleased) {
          if (autoEnableCounter > AUTO_MAX_COUNTER) {
            autoEnableCounter = 0;
          }
          else {
            isAuto = !isAuto;
            set_LED_Auto(isAuto);
            autoEnableCounter = 0;
          }
          isAutoReleased = false;
          isLongPress = false;
          play_menu_down();
        }
        if (isSleepReleased) {
          // if (!isSleep) {
          //   fill_solid(leds, NUM_LEDS, CRGB::Black); // Ensure LEDs are initially off
          //   FastLED.show();
          //   offDisp();
          //   dispSegment(DISP_OFF);
          //   // fill_solid(leds, NUM_LEDS, CRGB(0, 0, 0));
          //   isSleep = true;
          //   play_device_off();
          // } else if (isSleep) {
          //   isSleep = false;
          //   if (isTimer)
          //   dispSegment(hoursCount);
          //   onDisp();
          //   LEDs_Restore();
          //   play_device_on();
          // }
          // isSleepReleased = false;
          SleepMode = SleepMode + 1;
          if (SleepMode > MAX_Sleep_Mode)
          SleepMode = 0;
          switch(SleepMode){
                 case 0:
                      isSleep = false;
                      if (isTimer)
                      dispSegment(hoursCount);
                      onDisp();
                      LEDs_Restore();
                      play_device_on();
                      break;
                 case 1:
                      isSleep = true;
                       breathEffect = false;                               
                      fill_solid(leds, NUM_LEDS, CRGB::Black); // Ensure LEDs are initially off
                      FastLED.show();
                      break;  
                 case 2:
                      offDisp();
                      dispSegment(DISP_OFF);
                    //   // fill_solid(leds, NUM_LEDS, CRGB(0, 0, 0));
                      isSleep = true;
                      breathEffect = false;
                      play_device_off(); 
                      break;  
                 default:
                      isSleep = false;
                      if (isTimer)
                      dispSegment(hoursCount);
                      onDisp();
                      LEDs_Restore();
                      play_device_on();
                      break;                   
          }
          play_menu_up();
          // Reset the `isSpeedReleased` flag to wait for the next button press
          isSleepReleased = false;
        
        }
  //         }
             
  //       }
  //       break;
  //     }
  //   default:
  //     break;
  // }

      }
  }
}

void onDisp(void)
{
    gfx->clearScreen();
  // gfx->begin();
  if (sysState == STATE_POWER_ON)
  {
#ifdef DF_GFX_BL
    digitalWrite(DF_GFX_BL, HIGH);
#endif
    gfx->fillScreen(bgColor);
    gfx->drawCircle(120, 120, CIRCLE_RAD, foreColor);
    gfx->drawCircle(120, 120, CIRCLE_RAD + 1, foreColor);
    gfx->drawCircle(120, 120, CIRCLE_RAD + 2, foreColor);
    gfx->drawCircle(120, 120, CIRCLE_RAD + 3, foreColor);
    
    if (!isSleep) {
    gfx->setCursor(70, 25);
    gfx->setTextColor(foreColor, bgColor);
    gfx->setTextSize(5);
    int aqi = calculateAQI(map_p25);
    sprintf(buff, "%3d", aqi);
    // sprintf(buff, "%3d", fanSpeed);

    gfx->print(buff);
    }
  }
}

void onDisp_power_on(void)
{
  gfx->clearScreen();
#ifdef DF_GFX_BL
  digitalWrite(DF_GFX_BL, HIGH);
#endif
  gfx->fillScreen(bgColor);
  gfx->drawCircle(120, 120, CIRCLE_RAD, foreColor);
  gfx->drawCircle(120, 120, CIRCLE_RAD + 1, foreColor);
  gfx->drawCircle(120, 120, CIRCLE_RAD + 2, foreColor);
  gfx->drawCircle(120, 120, CIRCLE_RAD + 3, foreColor);


  gfx->setCursor(70, 25);
  gfx->setTextColor(foreColor, bgColor);
  gfx->setTextSize(5);
  int aqi = calculateAQI(map_p25);
  sprintf(buff, "%3d", aqi);
  // sprintf(buff, "%3d", fanSpeed);
  gfx->print(buff);
  
}

void offDisp(void)
{
  // fill_solid(leds, NUM_LEDS, CRGB(0, 0, 255));
  // FastLED.show();
  gfx->fillScreen(BLACK);
  gfx->clearScreen();
  dispSegment(DISP_OFF);

#ifdef DF_GFX_BL
  digitalWrite(DF_GFX_BL, LOW);
    gfx->clearScreen();
#endif
  gfx->clearScreen();
  gfx->fillScreen(BLACK);
  // fill_solid(leds, NUM_LEDS, CRGB(0, 0, 0));
  FastLED.clear();
  FastLED.show();
}

void zeroDetect_ISR() {
  if (digitalRead(ZERO_DETECT_PIN) == 1 && fanSpeed != 0) {
    pwmCount = 10;
    digitalWrite(PIN_PWM, LOW);
    if (fanSpeed == MAX_FAN_SPEED)
      digitalWrite(PIN_PWM, HIGH);
      // delayMicroseconds(10); // Maintain the pulse width for the triac
      // digitalWrite(PIN_PWM, LOW);
    flagON = true;
  }
}

int calculateAQI(uint16_t pm25) {
  uint16_t Clow, Chigh;
  int AQIlow, AQIhigh;

  if (pm25 <= 12) {
    Clow = 0; Chigh = 12; AQIlow = 0; AQIhigh = 50;
  } else if (pm25 <= 35) {
    Clow = 13; Chigh = 35; AQIlow = 51; AQIhigh = 100;
  } else if (pm25 <= 55) {
    Clow = 36; Chigh = 55; AQIlow = 101; AQIhigh = 150;
  } else if (pm25 <= 150) {
    Clow = 56; Chigh = 150; AQIlow = 151; AQIhigh = 200;
  } else if (pm25 <= 250) {
    Clow = 151; Chigh = 250; AQIlow = 201; AQIhigh = 300;
  } else if (pm25 <= 500) {
    Clow = 251; Chigh = 500; AQIlow = 301; AQIhigh = 500;
  } else {
    // If PM2.5 exceeds the AQI limits, return maximum AQI
    return 500;
  }

  // Calculate AQI using integer math
  int AQI = ((AQIhigh - AQIlow) * (pm25 - Clow)) / (Chigh - Clow) + AQIlow;
  return AQI;
}

boolean readPMSdata(Stream *s) {
  if (! s->available()) {
    return false;
  }

  // Read a byte at a time until we get to the special '0x42' start-byte
  if (s->peek() != 0x42) {
    s->read();
    return false;
  }

  // Now read all 32 bytes
  if (s->available() < 32) {
    return false;
  }

  uint8_t buffer[32];
  uint16_t sum = 0;
  s->readBytes(buffer, 32);

  // get checksum ready
  for (uint8_t i = 0; i < 30; i++) {
    sum += buffer[i];
  }

  // The data comes in endian'd, this solves it so it works on all platforms
  uint16_t buffer_u16[15];
  for (uint8_t i = 0; i < 15; i++) {
    buffer_u16[i] = buffer[2 + i * 2 + 1];
    buffer_u16[i] += (buffer[2 + i * 2] << 8);
  }

  // put it into a nice struct :)
  memcpy((void *)&data, (void *)buffer_u16, 30);

  if (sum != data.checksum) {
    return false;
  }
  // success!
  return true;
}

void init_pcf(void)
{
  // Set pinMode to OUTPUT
  pcf8574.pinMode(P0, OUTPUT);
  pcf8574.pinMode(P1, OUTPUT);
  pcf8574.pinMode(P2, OUTPUT);
  pcf8574.pinMode(P3, OUTPUT);
  pcf8574.pinMode(P4, OUTPUT);
  pcf8574.pinMode(P5, OUTPUT);
  pcf8574.pinMode(P6, OUTPUT);
  pcf8574.pinMode(P7, OUTPUT);

  // Set all outputs high
  pcf8574.digitalWrite(P0, HIGH);
  pcf8574.digitalWrite(P1, HIGH);
  pcf8574.digitalWrite(P2, HIGH);
  pcf8574.digitalWrite(P3, HIGH);
  pcf8574.digitalWrite(P4, LOW);
  pcf8574.digitalWrite(P5, HIGH);
  pcf8574.digitalWrite(P6, LOW);
  pcf8574.digitalWrite(P7, HIGH);


  pcf8574.begin();
}

void initButtons(void) {
  DDRC   &= ~((1 << DDC0) | (1 << DDC1) | (1 << DDC2));       // Set as input (Using for interupt PCINT1)
  DDRD   &= ~((1 << DDD4) | (1 << DDD5));       // Set as input (Using for interupt PCINT2)
  PORTC  |= ((1 << PORTC0) | (1 << PORTC1) | (1 << PORTC2));     // Enable pull-up resistor
  PORTD  |= ((1 << PORTD4) | (1 << PORTD5));     // Enable pull-up resistor
  // Setting Pin Change ISR for Buttons
  PCMSK1 |= ((1 << PCINT8) | (1 << PCINT9) | (1 << PCINT10));     // want pin PCINT8-10
  PCMSK2 |= ((1 << PCINT20) | (1 << PCINT21));     // want pin PCINT20-21
  PCIFR  |= ((1 << PCIF1) | (1 << PCIF2));      // clear any outstanding interrupts
  PCICR  |= ((1 << PCIE1) | (1 << PCIE2));      // enable pin change interrupts for PCINT8-10 and PCINT20-21
}

void Enable_Timer0(void) {
  TCCR0B &= ~((1 << CS00) | (1 << CS01) | (1 << CS02)) ;    // Turn OFF Timer
  // Setting Timer1 for PWM control
  TCCR0A |= (1 << WGM01);                                 // Set the Timer Mode to CTC
  TCCR0B |= (1 << CS00) | (1 << CS01) ;                   // set pre-scaler to 64 and start the timer
  OCR0A = TIM0_OVF;                                       // Set 249 as value to count to
  TIMSK0 |= (1 << OCIE0A);                                //Set the ISR COMPA vector
}

void dispSegment(int digit) {
  if (!isSleep){
  gfx->setCursor(70, 25);
  gfx->setTextColor(foreColor, bgColor);
  gfx->setTextSize(5);
  sprintf(buff, "0%dH", digit);
  gfx->print(buff);
  }
}

void set_LED_Sleep(bool b1) {
  if (!isSleep) {
    if (b1 == true)      gfx->drawBitmap(25, 100, sleepSign, 46, 47, foreColor);
    else                gfx->drawBitmap(25, 100, sleepSign, 46, 47, bgColor);
  }
  if (b1 == true)      ledStatus |= (1 << LED_SLEEP);
  else        ledStatus &= ~(1 << LED_SLEEP);
}

void set_LED_Fan(bool b1) {
  if (!isSleep) {
    if (b1 == true) {
      gfx->drawBitmap(93, 160, fan, 58, 58, foreColor);
      gfx->drawCircle(122, 188, 31, foreColor);
      gfx->drawCircle(122, 188, 30, foreColor);
      gfx->drawCircle(122, 188, 29, foreColor);
    }
    else {
      gfx->drawBitmap(93, 160, fan, 58, 58, bgColor);
      gfx->drawCircle(122, 188, 31, bgColor);
      gfx->drawCircle(122, 188, 30, bgColor);
      gfx->drawCircle(122, 188, 29, bgColor);
    }
  }
  if (b1 == true)      ledStatus |= (1 << LED_FAN);
  else        ledStatus &= ~(1 << LED_FAN);
}

void set_LED_Auto(bool b1) {
  if (!isSleep && sysState == STATE_POWER_ON) {
    if (b1 == true)      gfx->drawBitmap(175, 95, refresh, 43, 47, foreColor);
    else                gfx->drawBitmap(175, 95, refresh, 43, 47, bgColor);
  }
  if (b1 == true)      ledStatus |= (1 << LED_AUTO_MODE);
  else        ledStatus &= ~(1 << LED_AUTO_MODE);
}

void set_LED_Speed(unsigned char uc1) {
  switch (uc1)
  {
    case 0:     // Speed : 0, OFF
      if (!isSleep) {
        set_LED_Fan(false);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, bgColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, bgColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
      }
      ledStatus &= ~((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH_DIM));
      break;
    case 1:     // Speed : 1
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, bgColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
      }
      ledStatus |= ((1 << LED_SPEED_LOW) | (1 << LED_SPEED_LOW_DIM));
      ledStatus &= ~((1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH_DIM));
      break;
    case 2:     // Speed : 2
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, foreColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
      }
      ledStatus |= (1 << LED_SPEED_LOW);
      ledStatus &= ~((1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH) | (1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH_DIM));
      break;
    case 3:     // Speed : 3
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, foreColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, foreColor);
      }
      ledStatus |= ((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED) | (1 << LED_SPEED_MED_DIM));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_HIGH) | (1 << LED_SPEED_HIGH_DIM));
      break;
    case 4:     // Speed : 4
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, foreColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
      }
      ledStatus |= ((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH) | (1 << LED_SPEED_HIGH_DIM));
      break;
    case 5:     // Speed : 5
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, foreColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, dimColor);
      }
      ledStatus |= ((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH) | (1 << LED_SPEED_HIGH_DIM));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM));
      break;
    case 6:     // Speed : 6
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, foreColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, foreColor);
      }
      ledStatus |= ((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH_DIM));
      break;
    default:    // Speed : 0, Unknown input, OFF
      set_LED_Fan(false);
      gfx->drawBitmap(103, 120, wifi1, 35, 17, bgColor);
      gfx->drawBitmap(92, 100, wifi2, 56, 21, bgColor);
      gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
      ledStatus &= ~((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH_DIM));
      break;
  }
}

void LEDs_Restore(void)
{
  set_LED_Fan((bool)(ledStatus & NUM_LED_FAN));
  set_LED_Auto((bool)(ledStatus & NUM_LED_AUTO));
  if (((ledStatus & NUM_LED_SPEED_LOW) == NUM_LED_SPEED_LOW) && ((ledStatus & NUM_LED_SPEED_LOW_DIM) == NUM_LED_SPEED_LOW_DIM))
    gfx->drawBitmap(103, 120, wifi1, 35, 17, dimColor);
  else if (((ledStatus & NUM_LED_SPEED_LOW) == NUM_LED_SPEED_LOW) && ((ledStatus & NUM_LED_SPEED_LOW_DIM) == 0))
    gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
  else if (((ledStatus & NUM_LED_SPEED_LOW) == 0) && ((ledStatus & NUM_LED_SPEED_LOW_DIM) == 0))
    gfx->drawBitmap(103, 120, wifi1, 35, 17, bgColor);

  if (((ledStatus & NUM_LED_SPEED_MED) == NUM_LED_SPEED_MED) && ((ledStatus & NUM_LED_SPEED_MED_DIM) == NUM_LED_SPEED_MED_DIM))
    gfx->drawBitmap(92, 100, wifi2, 56, 21, dimColor);
  else if (((ledStatus & NUM_LED_SPEED_MED) == NUM_LED_SPEED_MED) && ((ledStatus & NUM_LED_SPEED_MED_DIM) == 0))
    gfx->drawBitmap(92, 100, wifi2, 56, 21, foreColor);
  else if (((ledStatus & NUM_LED_SPEED_MED) == 0) && ((ledStatus & NUM_LED_SPEED_MED_DIM) == 0))
    gfx->drawBitmap(92, 100, wifi2, 56, 21, bgColor);

  if (((ledStatus & NUM_LED_SPEED_HIGH) == NUM_LED_SPEED_HIGH) && ((ledStatus & NUM_LED_SPEED_HIGH_DIM) == NUM_LED_SPEED_HIGH_DIM))
    gfx->drawBitmap(82, 80, wifi3, 76, 25, dimColor);
  else if (((ledStatus & NUM_LED_SPEED_HIGH) == NUM_LED_SPEED_HIGH) && ((ledStatus & NUM_LED_SPEED_HIGH_DIM) == 0))
    gfx->drawBitmap(82, 80, wifi3, 76, 25, foreColor);
  else if (((ledStatus & NUM_LED_SPEED_HIGH) == 0) && ((ledStatus & NUM_LED_SPEED_HIGH_DIM) == 0))
    gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
}

void play_device_on(void)
{
  pcf8574.digitalWrite(P0, LOW);
  delay(MUSIC_PLAY_TIME);
  pcf8574.digitalWrite(P0, HIGH);
}

void play_device_off(void)
{
  pcf8574.digitalWrite(P1, LOW);
  delay(MUSIC_PLAY_TIME);
  pcf8574.digitalWrite(P1, HIGH);
}

void play_menu_up(void)
{
  pcf8574.digitalWrite(P2, LOW);
  delay(MUSIC_PLAY_TIME);
  pcf8574.digitalWrite(P2, HIGH);
}

void play_menu_down(void)
{
  pcf8574.digitalWrite(P3, LOW);
  delay(MUSIC_PLAY_TIME);
  pcf8574.digitalWrite(P3, HIGH);
}
