/*******************************************************************************
   Arduino_GFX setting
   Arduino Nano, Micro and more: CS:  9, DC:  8, RST:  7, BL:  6
 ******************************************************************************/
#include <Arduino_GFX_Library.h>
#include <EEPROM.h>
#include "PCF8574.h"
#include "FastLED.h"

//NeoPixle definations
#define NUM_LEDS 78
#define DATA_PIN 10
CRGB leds[NUM_LEDS];

#if defined(DISPLAY_DEV_KIT)
Arduino_GFX *gfx = create_default_Arduino_GFX();
#else /* !defined(DISPLAY_DEV_KIT) */

Arduino_DataBus *bus = create_default_Arduino_DataBus();

Arduino_GFX *gfx = new Arduino_GC9A01(bus, 7 /* RST */, 0 /* rotation */, true /* IPS */);
#endif /* !defined(DISPLAY_DEV_KIT) */

// Set i2c address
//PCF8574 pcf8574(0x20);
PCF8574 pcf8574(0x38);

#define ZERO_DETECT_PIN 2       // the number of the zeroDetct pin.
#define PIN_PWM 3               // Motor PWM Pin
#define PIN_BUZZ 19
#define PIN_LED 5				// For BreathEffect
#define PIN_CURRENT_SENSE A3    // For Current Sensor

#define CHK_BTN_AUTO 1
#define CHK_BTN_SLEEP 2
#define CHK_BTN_ON_OFF 4
#define CHK_BTN_SPEED 32
#define CHK_BTN_TIMER 16

#define BUZZ_MAX_TIME 5

#define CIRCLE_RAD 115
#define TIM0_OVF 249     // Interrupt overflow count 1mSec
#define INCR 80

#define LED_FAN 12          	// Blue
#define LED_AUTO_MODE 9//7     	// Blue
#define LED_SLEEP 7//9         	// Blue
#define LED_SPEED_LOW 11    	// Blue
#define LED_SPEED_MED 10    	// Blue
#define LED_SPEED_HIGH 8    	// Blue
#define LED_SPEED_LOW_DIM 13 	// For ledStatus
#define LED_SPEED_MED_DIM 14    // For ledStatus
#define LED_SPEED_HIGH_DIM 15   // For ledStatus

// For Sleep and Restore Functionality
#define NUM_LED_AUTO 512//128
#define NUM_LED_SPEED_HIGH 256
#define NUM_LED_SLEEP 128//512
#define NUM_LED_SPEED_MED 1024
#define NUM_LED_SPEED_LOW 2048
#define NUM_LED_FAN 4096
#define NUM_LED_SPEED_LOW_DIM 8192
#define NUM_LED_SPEED_MED_DIM 16384
#define NUM_LED_SPEED_HIGH_DIM 32768

#define SPEED_MULTIPLIER 1.5
#define MAX_FAN_SPEED 6
#define MAX_HOURS 8
#define ONE_HOUR_COUNT 3516000//58600//3600000
#define DISP_OFF 0

#define MAX_COUNT_BREATH 30
#define MAX_BRIGHTNESS 255

#define PM25_LVL0_VAL 50    // AQI 0 – 50
#define PM25_LVL1_VAL 100   // AQI 51 – 100
#define PM25_LVL2_VAL 150   // AQI 101 – 150
#define PM25_LVL3_VAL 200   // AQI 151 – 200
#define PM25_LVL4_VAL 300   // AQI 201 – 300
#define PM25_LVL5_VAL 500   // AQI 301 – 500

#define PM25_LVL0 0
#define PM25_LVL1 1
#define PM25_LVL2 2
#define PM25_LVL3 3
#define PM25_LVL4 4
#define PM25_LVL5 5
#define PM25_LVL6 6

#define MUSIC_PLAY_TIME 500  //mili seconds

#define CURRENT_SAMPLES 100
#define CURRENT_SAMPLES_F 100.0
#define CHANGE_HEPA_FILTER 500.0
#define HYSTERSIS_VALUE 100.0
#define CHECK_HEPA_FILTER_STATUS 10000 // time in milliSec

#define SPEED_CHANGED_DELAY 1500

volatile unsigned char airQualityPM01, airQualityPM25;
// Buzzer variables
volatile int buzzCount = 0;
volatile bool isBuzz = false;
// Buttons variables
volatile bool isAutoPressed = false;
volatile bool isSleepPressed = false;
volatile bool isPowerPressed = false;
volatile bool isSpeedPressed = false;
volatile bool isTimerPressed = false;
volatile bool isAutoReleased = false;
volatile bool isSleepReleased = false;
volatile bool isPowerReleased = false;
volatile bool isSpeedReleased = false;
volatile bool isTimerReleased = false;

volatile int hoursCount = 0;
volatile long hoursCounter = 0;
unsigned char countTimerDisp = 0;
volatile unsigned char fanSpeed = 0;
unsigned char auto_fan_speed = 0;
volatile unsigned char pwmCount = 0;
volatile bool flagON = false;
volatile bool flagTimerSet = false;
#define STATE_POWER_OFF 0
#define STATE_POWER_ON 1
volatile unsigned char sysState = STATE_POWER_OFF;
volatile unsigned int autoEnableCounter = 0;
volatile bool isAuto = false;
volatile bool isLongPress = false;
volatile bool breathEffect = false;
int brightness = 0;    // how bright the LED is
int fadeAmount = 3;    // how many points to fade the LED by
volatile unsigned char countBreath = 0;
volatile bool isTimer = false;
volatile bool isSleep = false;
#define AUTO_MAX_COUNTER 2000
uint16_t ledStatus = 0;

const unsigned char fan [] PROGMEM = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xfc, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0xf, 0xf8, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x3f, 0xf8, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xe0, 0x0, 0xf0, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xe0, 0x7, 0xfc, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xe0, 0xf, 0xfe, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xc0, 0x3f, 0xff, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xc0, 0x3f, 0xff, 0x80, 0x0,
  0x0, 0x0, 0xff, 0xc0, 0x7f, 0xff, 0xc0, 0x0,
  0x0, 0x0, 0xff, 0x80, 0x7f, 0xff, 0xc0, 0x0,
  0x0, 0x0, 0xff, 0x80, 0xff, 0xff, 0xe0, 0x0,
  0x1, 0x0, 0x7f, 0x80, 0xff, 0xff, 0xe0, 0x0,
  0x3, 0x80, 0x7f, 0xd1, 0xff, 0xff, 0xf0, 0x0,
  0x3, 0x80, 0x3f, 0xff, 0xff, 0xe0, 0x0, 0x0,
  0x7, 0x80, 0x3f, 0xff, 0xff, 0x0, 0x0, 0x0,
  0x7, 0xc0, 0x3f, 0xff, 0xfe, 0x0, 0x0, 0x0,
  0x7, 0xe0, 0x1f, 0xff, 0xfc, 0x0, 0x0, 0x0,
  0xf, 0xf0, 0xf, 0xff, 0xfc, 0x0, 0x0, 0x0,
  0xf, 0xf0, 0x1f, 0xff, 0xfc, 0x0, 0x0, 0x0,
  0xf, 0xfc, 0x1f, 0xff, 0xfe, 0x0, 0x0, 0x0,
  0xf, 0xfe, 0x3f, 0xff, 0xff, 0xfe, 0x0, 0x0,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0x3f, 0xfc, 0x0,
  0x0, 0x7, 0xff, 0xff, 0xfe, 0xf, 0xfc, 0x0,
  0x0, 0x0, 0x1f, 0xff, 0xfe, 0x7, 0xfc, 0x0,
  0x0, 0x0, 0xf, 0xff, 0xfc, 0x3, 0xfc, 0x0,
  0x0, 0x0, 0x7, 0xff, 0xfe, 0x1, 0xfe, 0x0,
  0x0, 0x0, 0xf, 0xff, 0xfe, 0x0, 0xf8, 0x0,
  0x0, 0x0, 0x1f, 0xff, 0xff, 0x0, 0xf8, 0x0,
  0x0, 0x0, 0x7f, 0xff, 0xff, 0x0, 0x70, 0x0,
  0x3, 0xf, 0xff, 0xf0, 0xff, 0x80, 0x70, 0x0,
  0x3, 0xff, 0xff, 0xe0, 0x7f, 0x80, 0x30, 0x0,
  0x1, 0xff, 0xff, 0xe0, 0x7f, 0x80, 0x20, 0x0,
  0x0, 0xff, 0xff, 0xc0, 0x7f, 0xc0, 0x0, 0x0,
  0x0, 0xff, 0xff, 0x80, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x7f, 0xff, 0x80, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x3f, 0xff, 0x0, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x1f, 0xfe, 0x0, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0xf, 0xfc, 0x1, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x7, 0xf0, 0x1, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x3, 0xc0, 0x3, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3, 0xff, 0x80, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x7, 0xfe, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xf, 0xf0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};

const unsigned char refresh [] PROGMEM = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x3, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x7, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x1f, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x7f, 0x0, 0x0, 0x0,
  0x0, 0x0, 0xff, 0x0, 0x0, 0x0,
  0x0, 0x3, 0xff, 0xe0, 0x0, 0x0,
  0x0, 0xf, 0xff, 0xfe, 0x0, 0x0,
  0x0, 0x1f, 0xff, 0xff, 0x0, 0x0,
  0x0, 0x1f, 0xff, 0xff, 0xc0, 0x0,
  0x0, 0xf, 0xff, 0xff, 0xe0, 0x0,
  0x0, 0x7, 0xff, 0xff, 0xf0, 0x0,
  0x0, 0x1, 0xff, 0xff, 0xf8, 0x0,
  0x0, 0x0, 0x7f, 0x3f, 0xfc, 0x0,
  0x1, 0x80, 0x1f, 0xf, 0xfc, 0x0,
  0x7, 0xe0, 0x7, 0x3, 0xfe, 0x0,
  0xf, 0xe0, 0x3, 0x1, 0xfe, 0x0,
  0xf, 0xe0, 0x0, 0x1, 0xff, 0x0,
  0x1f, 0xe0, 0x0, 0x1, 0xff, 0x0,
  0x1f, 0xe0, 0x0, 0x0, 0x7f, 0x80,
  0x1f, 0xe0, 0x0, 0x0, 0x7f, 0x80,
  0x3f, 0xc0, 0x0, 0x0, 0x3f, 0xc0,
  0x7f, 0xc0, 0x0, 0x0, 0x3f, 0xc0,
  0x7f, 0xc0, 0x0, 0x0, 0x3f, 0xc0,
  0x7f, 0x80, 0x0, 0x0, 0x1f, 0xc0,
  0x7f, 0x80, 0x0, 0x0, 0x3f, 0xc0,
  0x3f, 0x80, 0x0, 0x0, 0x3f, 0xc0,
  0x3f, 0x80, 0x0, 0x0, 0x3f, 0xc0,
  0x3f, 0xc0, 0x0, 0x0, 0x3f, 0xc0,
  0x1f, 0xc0, 0x0, 0x0, 0x3f, 0xc0,
  0x1f, 0xc0, 0x0, 0x0, 0x7f, 0x80,
  0x1f, 0xf0, 0x0, 0x0, 0x7f, 0x80,
  0x1f, 0xf0, 0x0, 0x0, 0xff, 0x0,
  0xf, 0xf8, 0x0, 0x1, 0xfe, 0x0,
  0xf, 0xf8, 0x0, 0x3, 0xfe, 0x0,
  0x7, 0xfe, 0x0, 0x7, 0xfe, 0x0,
  0x7, 0xff, 0x0, 0xf, 0xfc, 0x0,
  0x1, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x1, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x0, 0x7f, 0xff, 0xff, 0xe0, 0x0,
  0x0, 0x7f, 0xff, 0xff, 0xe0, 0x0,
  0x0, 0x1f, 0xff, 0xff, 0x80, 0x0,
  0x0, 0xf, 0xff, 0xfe, 0x0, 0x0,
  0x0, 0x3, 0xff, 0xf8, 0x0, 0x0,
  0x0, 0x0, 0x3f, 0xc0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};

const unsigned char sleepSign [] PROGMEM = {
  0x0, 0x18, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x38, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x78, 0x0, 0x0, 0x0, 0x0,
  0x0, 0xf0, 0x0, 0x0, 0x0, 0x0,
  0x1, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x1, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x3, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x7, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0xf, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0xf, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0x1f, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0x1f, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x3f, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x3f, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0xff, 0xc0, 0x0, 0x0, 0x0, 0x0,
  0xff, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0xff, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xf0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xf0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xf8, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xfc, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xfc, 0x0, 0x0, 0x0, 0x0,
  0x3f, 0xfe, 0x0, 0x0, 0x0, 0x0,
  0x3f, 0xff, 0x0, 0x0, 0x0, 0x0,
  0x3f, 0xff, 0x80, 0x0, 0x0, 0x0,
  0x1f, 0xff, 0xc0, 0x0, 0x0, 0x0,
  0xf, 0xff, 0xf0, 0x0, 0x0, 0x0,
  0xf, 0xff, 0xf8, 0x0, 0x0, 0xc,
  0x7, 0xff, 0xfe, 0x0, 0x0, 0x3c,
  0x3, 0xff, 0xff, 0xc0, 0x0, 0xfc,
  0x1, 0xff, 0xff, 0xf8, 0xf, 0xf8,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xe0,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x1f, 0xff, 0xff, 0xff, 0x0,
  0x0, 0xf, 0xff, 0xff, 0xfc, 0x0,
  0x0, 0x3, 0xff, 0xff, 0xf0, 0x0,
  0x0, 0x0, 0xff, 0xff, 0xe0, 0x0,
  0x0, 0x0, 0x7f, 0xff, 0x80, 0x0,
  0x0, 0x0, 0x0, 0x88, 0x0, 0x0
};

const unsigned char wifi1 [] PROGMEM = {
  0x0, 0xf, 0xfe, 0x0, 0x0,
  0x0, 0x7f, 0xff, 0x0, 0x0,
  0x3, 0xff, 0xff, 0xe0, 0x0,
  0x7, 0xff, 0xff, 0xfc, 0x0,
  0x1f, 0xff, 0xff, 0xfe, 0x0,
  0x3f, 0xff, 0xff, 0xff, 0x80,
  0x7f, 0xff, 0xff, 0xff, 0xc0,
  0xff, 0xff, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xff, 0xff, 0xe0,
  0x7f, 0xff, 0xff, 0xff, 0xe0,
  0x7f, 0xff, 0xff, 0xff, 0xc0,
  0x3f, 0xff, 0xff, 0xff, 0x80,
  0x3f, 0xf0, 0x3, 0xff, 0x0,
  0x1f, 0xc0, 0x0, 0x7e, 0x0,
  0x1f, 0x80, 0x0, 0x3c, 0x0,
  0xf, 0x0, 0x0, 0x1c, 0x0,
  0x4, 0x0, 0x0, 0x0, 0x0
};

const unsigned char wifi2 [] PROGMEM = {
  0x0, 0x0, 0x7, 0xff, 0xf0, 0x0, 0x0,
  0x0, 0x0, 0x7f, 0xff, 0xff, 0x0, 0x0,
  0x0, 0x1, 0xff, 0xff, 0xff, 0x80, 0x0,
  0x0, 0xf, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x0, 0x1f, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
  0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
  0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,
  0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,
  0x7f, 0xff, 0xff, 0x8f, 0xff, 0xff, 0xfe,
  0xff, 0xff, 0xfc, 0x0, 0x1f, 0xff, 0xff,
  0x7f, 0xff, 0xc0, 0x0, 0x3, 0xff, 0xfe,
  0x3f, 0xff, 0x0, 0x0, 0x0, 0xff, 0xfe,
  0x1f, 0xfc, 0x0, 0x0, 0x0, 0x3f, 0xfc,
  0x1f, 0xf8, 0x0, 0x0, 0x0, 0xf, 0xf8,
  0xf, 0xf0, 0x0, 0x0, 0x0, 0x7, 0xf0,
  0x7, 0xe0, 0x0, 0x0, 0x0, 0x3, 0xe0,
  0x7, 0xc0, 0x0, 0x0, 0x0, 0x1, 0xe0,
  0x3, 0x80, 0x0, 0x0, 0x0, 0x0, 0x40
};

const unsigned char wifi3 [] PROGMEM = {
  0x0, 0x0, 0x0, 0x0, 0xf1, 0xf8, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0,
  0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0,
  0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0,
  0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0,
  0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0xf, 0xff, 0xff, 0xff, 0x0, 0x87, 0xff, 0xff, 0xff, 0x0,
  0x3f, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xc0,
  0x7f, 0xff, 0xff, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xe0,
  0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xf0,
  0x7f, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xf0,
  0x3f, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xe0,
  0x1f, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xe0,
  0x1f, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xc0,
  0xf, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x80,
  0x7, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x0,
  0x7, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0x0,
  0x3, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0x0,
  0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0
};

const unsigned char leaf [] PROGMEM = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x78, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf8, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xf8, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xf8, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xfc, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x1f, 0xff, 0xff, 0xff, 0xfe, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x1f, 0xff, 0xff, 0xff, 0xf8, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x3f, 0xff, 0xff, 0xff, 0xc0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x7f, 0xff, 0xff, 0xff, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0x7f, 0xff, 0xff, 0xfc, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x0, 0xff, 0xff, 0xff, 0xf0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0,
  0x1, 0xff, 0xff, 0xff, 0xc0, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x1, 0xff, 0xff, 0xff, 0x80, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x3, 0xff, 0xff, 0xfe, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x3, 0xff, 0xff, 0xfc, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x3, 0xff, 0xff, 0xf8, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x7, 0xff, 0xff, 0xf0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x7, 0xff, 0xff, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0xf, 0xff, 0xff, 0xc0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0xf, 0xff, 0xff, 0x80, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0xf, 0xff, 0xff, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80,
  0x1f, 0xff, 0xfe, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x1f, 0xff, 0xfc, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x1f, 0xff, 0xf8, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x1f, 0xff, 0xf0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x3f, 0xff, 0xf0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
  0x3f, 0xff, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x3f, 0xff, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x3f, 0xff, 0xc0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x3f, 0xff, 0x80, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0,
  0x3f, 0xff, 0x80, 0x7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x7f, 0xff, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x7f, 0xff, 0x0, 0xf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0,
  0x7f, 0xfe, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x7f, 0xfe, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x7f, 0xfe, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0,
  0x7f, 0xfc, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x7f, 0xfc, 0x0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x7f, 0xfc, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0,
  0x7f, 0xf8, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0,
  0x7f, 0xf8, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0,
  0x7f, 0xf8, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0,
  0x7f, 0xf8, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0,
  0x7f, 0xf0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0,
  0x7f, 0xf0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0,
  0x7f, 0xf0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0,
  0x3f, 0xf0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0,
  0x3f, 0xf0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0,
  0x3f, 0xf0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0,
  0x3f, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0,
  0x3f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0,
  0x3f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0,
  0x1f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0,
  0x1f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0,
  0x1f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0,
  0x1f, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0,
  0xf, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0,
  0xf, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0,
  0xf, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
  0xf, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0,
  0x7, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0,
  0x7, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0,
  0x7, 0xe0, 0x3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0,
  0x3, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0,
  0x3, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0,
  0x3, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x0, 0x0,
  0x1, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0, 0x0, 0x0, 0x0,
  0x1, 0xe0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x0, 0x0, 0x0, 0x0,
  0x1, 0xe0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0,
  0x0, 0xe0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0xe0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3f, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x3, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
};

// 'Filter1', 50x50px
const unsigned char filter1 [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x07,
  0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x3f, 0xfc, 0xcf, 0xff, 0x00, 0x00, 0x01, 0xfc, 0x00, 0xc0,
  0x3f, 0xe0, 0x00, 0x07, 0xff, 0x0f, 0xfc, 0xf0, 0xf8, 0x00, 0x0f, 0x1f, 0xff, 0xff, 0xe0, 0x3c,
  0x00, 0x1c, 0x03, 0xf0, 0x03, 0xe0, 0x0e, 0x00, 0x1c, 0x07, 0x80, 0x00, 0x78, 0x0e, 0x00, 0x1f,
  0xff, 0x00, 0x00, 0x3f, 0xfe, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x3c, 0x03, 0xe0,
  0x01, 0xf0, 0x0f, 0x00, 0x3e, 0x00, 0xff, 0xff, 0xc0, 0x1f, 0x00, 0x3f, 0x80, 0x3f, 0xff, 0x00,
  0x7f, 0x00, 0x3d, 0xf8, 0x00, 0xc0, 0x07, 0xe7, 0x00, 0x3c, 0x7f, 0xc0, 0xc0, 0xff, 0x8f, 0x00,
  0x3e, 0x0f, 0xff, 0xff, 0xfc, 0x1f, 0x00, 0x3e, 0x00, 0x7f, 0xff, 0x80, 0x1f, 0x00, 0x3e, 0x00,
  0x00, 0x00, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0x00, 0x00,
  0x00, 0x1f, 0x00, 0x3e, 0x07, 0x00, 0x00, 0x38, 0x1f, 0x00, 0x3e, 0x0f, 0x80, 0x00, 0x7c, 0x1f,
  0x00, 0x3e, 0x0f, 0xe0, 0x01, 0xfc, 0x1f, 0x00, 0x3e, 0x03, 0xf0, 0x03, 0xf0, 0x1f, 0x00, 0x3e,
  0x01, 0xf8, 0x07, 0xe0, 0x1f, 0x00, 0x3e, 0x00, 0xfc, 0x0f, 0xc0, 0x1f, 0x00, 0x3e, 0x00, 0x7f,
  0x3f, 0x80, 0x1f, 0x00, 0x3e, 0x00, 0x1f, 0xfe, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0x0f, 0xfc, 0x00,
  0x1f, 0x00, 0x3e, 0x00, 0x07, 0xf8, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0x07, 0xf8, 0x00, 0x1f, 0x00,
  0x3e, 0x00, 0x0f, 0xfc, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0x1f, 0xfe, 0x00, 0x1f, 0x00, 0x3e, 0x00,
  0x3f, 0x3f, 0x00, 0x1f, 0x00, 0x3e, 0x00, 0xfe, 0x1f, 0xc0, 0x1f, 0x00, 0x3e, 0x01, 0xf8, 0x07,
  0xe0, 0x1f, 0x00, 0x3e, 0x03, 0xf0, 0x03, 0xf0, 0x1f, 0x00, 0x3e, 0x07, 0xe0, 0x01, 0xf8, 0x1f,
  0x00, 0x3e, 0x0f, 0xc0, 0x00, 0xfc, 0x1f, 0x00, 0x1e, 0x07, 0x00, 0x00, 0x38, 0x1e, 0x00, 0x1e,
  0x02, 0x00, 0x00, 0x10, 0x1e, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0f, 0x00, 0x00,
  0x00, 0x00, 0x3c, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff,
  0xe0, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xf8, 0x00, 0x00,
  0x00, 0x01, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00
};

volatile bool flag_change_filter = false;
volatile bool flag_speed_changed = false;
char buff[10];
unsigned char colorCount = 1;
unsigned char wifiCount = 0;
unsigned long currMillis, prevMillis;
volatile unsigned int msCount = 0;
volatile int secCount = 0;
volatile bool flag_dispCount = true;
volatile bool flag_bgChange = false;
uint16_t bgColor = RED;      			// modify to change default background color
uint16_t NewbgColor;      				// modify to change default background color
uint16_t foreColor = BLACK;      		// modify to change default foreground color
uint16_t dimColor = NAVY;      			// modify to change default dim color
uint8_t red, green, blue;


float AcsValueF = 0.0;

// Function declarations
void Enable_Timer0(void);
void dispSegment(int);

struct pms5003data {
  uint16_t framelen;
  uint16_t pm10_standard, pm25_standard, pm100_standard;
  uint16_t pm10_env, pm25_env, pm100_env;
  uint16_t particles_01um, particles_05um, particles_10um, particles_25um, particles_50um, particles_100um;
  uint16_t unused;
  uint16_t checksum;
};

uint16_t map_p01 = 10;
uint16_t map_p25 = 50;
struct pms5003data data;

//EEPROM
/** the current address in the EEPROM  **/
int addr = 0;

//Interrupt Service Routine for PCINT1(PC0-PC4), Panel Buttons
ISR(PCINT1_vect) {
  // ON/OFF
  if (((PINC & CHK_BTN_ON_OFF) == CHK_BTN_ON_OFF) && !isPowerPressed) {
    //digitalWrite(PIN_BUZZ, LOW);
    isBuzz = true;      isPowerPressed = true;
  } else if (((PINC & CHK_BTN_ON_OFF) == 0) && isPowerPressed) {
    isPowerReleased = true;         isPowerPressed = false;
  }
  if (sysState == STATE_POWER_ON) {
    // Auto
    if (((PINC & CHK_BTN_AUTO) == CHK_BTN_AUTO) && !isAutoPressed && !isAutoReleased && !isSleep) {
      //digitalWrite(PIN_BUZZ, LOW);
      isBuzz = true;      isAutoPressed = true;
    } else if (((PINC & CHK_BTN_AUTO) == 0) && isAutoPressed) {
      isAutoReleased = true;          isAutoPressed = false;
    }
    // Sleep
    if (((PINC & CHK_BTN_SLEEP) == CHK_BTN_SLEEP) && !isSleepPressed && !isSleepReleased) {
      //digitalWrite(PIN_BUZZ, LOW);
      isBuzz = true;      isSleepPressed = true;
    } else if (((PINC & CHK_BTN_SLEEP) == 0) && isSleepPressed) {
      isSleepReleased = true;         isSleepPressed = false;
    }

  }
}

//Interrupt Service Routine for PCINT3(PD4-PD5), Panel Buttons
ISR(PCINT2_vect) {
  if (sysState == STATE_POWER_ON && !isSleep) {
    // Speed
    if (((PIND & CHK_BTN_SPEED) == CHK_BTN_SPEED) && !isSpeedPressed && !isSpeedReleased && !isAuto) {
      //digitalWrite(PIN_BUZZ, LOW);
      isBuzz = true;      isSpeedPressed = true;
    } else if (((PIND & CHK_BTN_SPEED) == 0) && isSpeedPressed) {
      isSpeedReleased = true;         isSpeedPressed = false;
    }
    // Timer
    if (((PIND & CHK_BTN_TIMER) == CHK_BTN_TIMER) && !isTimerPressed && !isTimerReleased) {
      //digitalWrite(PIN_BUZZ, LOW);
      isBuzz = true;      isTimerPressed = true;
    } else if (((PIND & CHK_BTN_TIMER) == 0) && isTimerPressed) {
      isTimerReleased = true;         isTimerPressed = false;
    }
  }
}

// Timer0 ISR after every 1mSec
ISR(TIMER0_COMPA_vect) {
  if (flagON) {	// For Motor Control Only
    pwmCount--;
    if (pwmCount <= 0) {
      digitalWrite(PIN_PWM, LOW);     flagON = false;
    }
    else if (pwmCount == ((unsigned char)(floor(fanSpeed * SPEED_MULTIPLIER)))) {
      digitalWrite(PIN_PWM, HIGH);
    }
  }

  if (sysState == STATE_POWER_ON) {
    if (flagTimerSet) {
      msCount++;
      if (msCount > 3000) {
        msCount = 0;
        flagTimerSet = false;
      }
    }
    if (isTimer) {
      hoursCounter--;
      if (hoursCounter < 1) {
        isPowerReleased = true;		isTimer = false;
      }
      /*if(!isSleep && ((hoursCounter % 10000) == 0)) {
      	dispSegment((int)(ceil(float(hoursCounter)/float(ONE_HOUR_COUNT))));
        }*/
    }
    // --> Block modification needed
    if (isAutoPressed == true) {
      autoEnableCounter++;
      if (autoEnableCounter > AUTO_MAX_COUNTER && !isLongPress) {
        breathEffect = !breathEffect;
        if (!breathEffect) {
          brightness = 0;
          analogWrite(PIN_LED, brightness);
        }
        isLongPress = true;
      }
    }
  }

  if (isBuzz == true) {
    buzzCount++;
    if (buzzCount > BUZZ_MAX_TIME) {
      buzzCount = 0;
      //digitalWrite(PIN_BUZZ, HIGH);
      isBuzz = false;
    }
  }

  if (breathEffect == true) {
    countBreath++;
    if (countBreath >= MAX_COUNT_BREATH) {
      countBreath = 0;
      brightness += fadeAmount;
      if (brightness < 3 || brightness > MAX_BRIGHTNESS) {
        fadeAmount = -fadeAmount;
        brightness += fadeAmount;
      }
      analogWrite(PIN_LED, brightness);
    }
  }
}

void setup(void)
{
    FastLED.addLeds<WS2812B, DATA_PIN>(leds, NUM_LEDS);
    init_pcf();
    gfx->begin();

#ifdef DF_GFX_BL
    pinMode(DF_GFX_BL, OUTPUT);
    digitalWrite(DF_GFX_BL, LOW);   
#endif
    offDisp();
    Serial.begin(9600);
    pinMode(PIN_LED, OUTPUT);      // initialize the LED pin

    initSegment();
    pinMode(ZERO_DETECT_PIN, INPUT);  // initialize the zeroDetct pin as an input:
    pinMode(PIN_PWM, OUTPUT);  // initialize the PWM pin as an input:
    digitalWrite(PIN_PWM, LOW);
    cli(); // clear Global Interrupt
    attachInterrupt(digitalPinToInterrupt(ZERO_DETECT_PIN), zeroDetect_ISR, CHANGE);
    initButtons();
    Enable_Timer0();
    sei(); // Enable the Global Interrupts
    //fanSpeed = EEPROM.read(addr); // Restore the speed
}

unsigned int x = 0;
float AcsValue = 0.0, Samples = 0.0, AvgAcs = 0.0;
unsigned long prev_millis;
unsigned long speed_changed_millis;

void loop()
{
  if ((millis() - prev_millis) > CHECK_HEPA_FILTER_STATUS)
  {
    for (int x = 0; x < CURRENT_SAMPLES; x++)
	  { //Get 150 samples
      AcsValue = analogRead(PIN_CURRENT_SENSE);     //Read current sensor values
      Samples = Samples + AcsValue;  //Add samples together
      delay (3); // let ADC settle before next sample 3ms
    }
    AvgAcs = Samples / CURRENT_SAMPLES_F; //Taking Average of Samples

    //((AvgAcs * (5.0 / 1024.0)) is converitng the read voltage in 0-5 volts
    //2.5 is offset(I assumed that arduino is working on 5v so the viout at no current comes
    //out to be 2.5 which is out offset. If your arduino is working on different voltage than
    //you must change the offset according to the input voltage)
    //0.185v(185mV) is rise in output voltage when 1A current flows at input
    AcsValueF = (2.5 - (AvgAcs * (5.0 / 1024.0)) ) / 0.185;

    if (AvgAcs > CHANGE_HEPA_FILTER && !flag_change_filter)
    {
      flag_change_filter = true;
      gfx->drawBitmap(20, 95, filter1, 50, 50, foreColor);
    }
    else if (AvgAcs < (CHANGE_HEPA_FILTER - HYSTERSIS_VALUE) && flag_change_filter)
    {
      flag_change_filter = false;
      gfx->drawBitmap(20, 95, filter1, 50, 50, bgColor);
    }
    prev_millis = millis();

    // Serial.println(AcsValue);
    // Serial.println(AvgAcs);
    // Serial.print("Avg Current : ");
    // Serial.println(AvgAcs);      //Print the read current on Serial monitor
  }
  if (readPMSdata(&Serial) && sysState == STATE_POWER_ON && flagTimerSet == false)
  {
    countTimerDisp++;
    map_p01 = data.pm10_env;	//data.pm10_standard;	//map(data.particles_01um, 0, 65535, 0, 1000);
    map_p25 = data.pm25_env;	//data.pm25_standard;	//map(data.particles_25um, 0, 65535, 0, 1000);
	  int aqi = calculateAQI(map_p25);
    
    if (countTimerDisp > 10)
    {
      countTimerDisp = 0;
      if (isTimer && !isSleep)
	    {
        dispSegment((int)(ceil(float(hoursCounter) / float(ONE_HOUR_COUNT))));
      }
    }
    else
	  {
      gfx->setCursor(70, 25);
      gfx->setTextColor(foreColor, bgColor);
      gfx->setTextSize(5);
      // sprintf(buff, "%3d", fanSpeed);
      sprintf(buff, "%3d", aqi);
      gfx->print(buff);
    }

    if (aqi <= PM25_LVL0_VAL) { // Clean Air PM25
      airQualityPM25 = PM25_LVL0;
      NewbgColor = GREEN; // changed requirements
      fill_solid(leds, NUM_LEDS, CRGB(0, 255, 0));
      FastLED.show();
    }
    else if (aqi > PM25_LVL0_VAL && aqi <= PM25_LVL1_VAL) {
      airQualityPM25 = PM25_LVL1;
      NewbgColor = YELLOW; // changed requirements
      fill_solid(leds, NUM_LEDS, CRGB(255, 255, 0));
      FastLED.show();
    }
    else if (aqi > PM25_LVL1_VAL && aqi <= PM25_LVL2_VAL) {
      airQualityPM25 = PM25_LVL2;
      NewbgColor = ORANGE;
      fill_solid(leds, NUM_LEDS, CRGB(255, 165, 0));
      FastLED.show();
    }
    else if (aqi > PM25_LVL2_VAL && aqi <= PM25_LVL3_VAL) {
      airQualityPM25 = PM25_LVL3;
      NewbgColor = RED;
      fill_solid(leds, NUM_LEDS, CRGB(255, 0, 0));
      FastLED.show();
    }
    else if (aqi > PM25_LVL3_VAL && aqi <= PM25_LVL4_VAL) {
      airQualityPM25 = PM25_LVL4;
      NewbgColor = PURPLE;
      fill_solid(leds, NUM_LEDS, CRGB(123, 0, 123));
      FastLED.show();
    }
    else if (aqi > PM25_LVL4_VAL && aqi <= PM25_LVL5_VAL) {
      airQualityPM25 = PM25_LVL5;
      NewbgColor = MAROON;
      fill_solid(leds, NUM_LEDS, CRGB(123, 0, 0));
      FastLED.show();
    }
    else if (aqi > PM25_LVL5_VAL) {
      airQualityPM25 = PM25_LVL6;
      NewbgColor = MAROON;
      fill_solid(leds, NUM_LEDS, CRGB(123, 0, 0));
      FastLED.show();
    }
    
    if (isAuto)
    {
      switch (airQualityPM25)
      {
        case PM25_LVL0:	fanSpeed = 0;	break;
        
        case PM25_LVL1:	fanSpeed = 1;	break;
        
        case PM25_LVL2:	fanSpeed = 2;	break;
        
        case PM25_LVL3:	fanSpeed = 3;	break;
        
        case PM25_LVL4:	fanSpeed = 4;	break;
        
        case PM25_LVL5:	fanSpeed = 5;	break;
        
        case PM25_LVL6:	fanSpeed = 6;	break;
        
        default:		fanSpeed = 0;	break;
      }
      if(auto_fan_speed != fanSpeed)
      {
        EEPROM.write(addr, fanSpeed);
        set_LED_Speed(fanSpeed);
        auto_fan_speed = fanSpeed;
      }
    }
  }

  if (NewbgColor != bgColor)
  {
    bgColor = NewbgColor;
    onDisp();
    set_LED_Speed(fanSpeed);
    set_LED_Auto(isAuto); // added for bug fixing version 2.2
  }

  switch (sysState)
  {
    case STATE_POWER_OFF:
      {
        if (isPowerReleased) {  // Turn ON Power
          play_device_on();

          digitalWrite(DF_GFX_BL, HIGH);
          gfx->fillScreen(WHITE);
          gfx->drawCircle(120, 120, CIRCLE_RAD, GREEN);
          gfx->drawCircle(120, 120, CIRCLE_RAD + 1, GREEN);
          gfx->drawCircle(120, 120, CIRCLE_RAD + 2, GREEN);
          gfx->drawCircle(120, 120, CIRCLE_RAD + 3, GREEN);
          gfx->drawBitmap(60, 60, leaf, 107, 122, GREEN);
          delay(3000);

          fanSpeed = EEPROM.read(addr); // Restore the speed
          onDisp_power_on();
          sysState = STATE_POWER_ON;
          set_LED_Speed(fanSpeed);
          breathEffect = false;       brightness = 0;     analogWrite(PIN_LED, brightness);
          isPowerReleased = false;
          flag_change_filter = false;
        }
        break;
      }
    case STATE_POWER_ON:
      {
        if (isPowerReleased) {  // Turn OFF Power
          play_device_off();
          hoursCount = 0;
          hoursCounter = 0;
          offDisp();
          dispSegment(DISP_OFF);
          set_LED_Speed(0);
          isAuto = false;
          set_LED_Auto(isAuto);
          EEPROM.write(addr, fanSpeed);// Write the speed
          fanSpeed = 0;
          isSleep = false;
          breathEffect = false;       brightness = 0;     analogWrite(PIN_LED, brightness);
          sysState = STATE_POWER_OFF;
          isPowerReleased = false;
        }
        if (isSpeedReleased && !flag_speed_changed) {
          if(fanSpeed == 0 || fanSpeed == 2 || fanSpeed == 4)
            fanSpeed = fanSpeed + 1;
          else
            fanSpeed = fanSpeed + 2;
          if (fanSpeed > MAX_FAN_SPEED)
            fanSpeed = 1;
          EEPROM.write(addr, fanSpeed);
          set_LED_Speed(fanSpeed);
          isSpeedReleased = false;
          play_menu_up();
          speed_changed_millis = millis();
          flag_speed_changed = true;
        }
        if (isTimerReleased) {
          isTimer = false;
          msCount = 0;
          flagTimerSet = true;
          hoursCount++;
          if (hoursCount > MAX_HOURS)
            hoursCount = 0;
          dispSegment(hoursCount);
          hoursCounter = hoursCount * ONE_HOUR_COUNT;
          if (hoursCounter == 0)
            dispSegment(DISP_OFF);
          else
            isTimer = true;
          isTimerReleased = false;
          play_menu_up();
        }
        if (isAutoReleased) {
          if (autoEnableCounter > AUTO_MAX_COUNTER) {
            autoEnableCounter = 0;
          }
          else {
            isAuto = !isAuto;
            set_LED_Auto(isAuto);
            autoEnableCounter = 0;
          }
          isAutoReleased = false;
          isLongPress = false;
          play_menu_down();
        }
        if (isSleepReleased) {
          if (!isSleep) {
            offDisp();
            dispSegment(DISP_OFF);
            isSleep = true;
            play_device_off();
          } else if (isSleep) {
            isSleep = false;
            if (isTimer)
              dispSegment(hoursCount);
            onDisp();
            LEDs_Restore();
            play_device_on();
          }
          isSleepReleased = false;
        }
        if(flag_speed_changed && ((millis()-speed_changed_millis) > SPEED_CHANGED_DELAY))
        {
          fanSpeed = fanSpeed + 1;
          if (fanSpeed > MAX_FAN_SPEED)
            fanSpeed = 1;
          EEPROM.write(addr, fanSpeed);
          set_LED_Speed(fanSpeed);
          flag_speed_changed = false;
        }
        break;
      }
    default:
      break;
  }
}

void onDisp(void)
{
  // gfx->begin();
  if(sysState == STATE_POWER_ON)
  {
    digitalWrite(DF_GFX_BL, HIGH);
    gfx->fillScreen(bgColor);
    gfx->drawCircle(120, 120, CIRCLE_RAD, foreColor);
    gfx->drawCircle(120, 120, CIRCLE_RAD + 1, foreColor);
    gfx->drawCircle(120, 120, CIRCLE_RAD + 2, foreColor);
    gfx->drawCircle(120, 120, CIRCLE_RAD + 3, foreColor);

    gfx->setCursor(70, 25);
    gfx->setTextColor(foreColor, bgColor);
    gfx->setTextSize(5);
    int aqi = calculateAQI(map_p25);
    sprintf(buff, "%3d", aqi);
    // sprintf(buff, "%3d", fanSpeed);
    
    gfx->print(buff);
  }
}

void onDisp_power_on(void)
{
  digitalWrite(DF_GFX_BL, HIGH);
  gfx->fillScreen(bgColor);
  gfx->drawCircle(120, 120, CIRCLE_RAD, foreColor);
  gfx->drawCircle(120, 120, CIRCLE_RAD + 1, foreColor);
  gfx->drawCircle(120, 120, CIRCLE_RAD + 2, foreColor);
  gfx->drawCircle(120, 120, CIRCLE_RAD + 3, foreColor);

  gfx->setCursor(70, 25);
  gfx->setTextColor(foreColor, bgColor);
  gfx->setTextSize(5);
  int aqi = calculateAQI(map_p25);
  sprintf(buff, "%3d", aqi);
  // sprintf(buff, "%3d", fanSpeed);
  
  gfx->print(buff);
}

void offDisp(void)
{
  gfx->fillScreen(BLACK);
  digitalWrite(DF_GFX_BL, LOW);
  fill_solid(leds, NUM_LEDS, CRGB(0, 0, 0));
  FastLED.show();
}

void zeroDetect_ISR() {
  if (digitalRead(ZERO_DETECT_PIN) == 1 && fanSpeed != 0) {
    // Enable_Timer0();
    pwmCount = 10;
    digitalWrite(PIN_PWM, LOW);
    if (fanSpeed == MAX_FAN_SPEED)
      digitalWrite(PIN_PWM, HIGH);
    flagON = true;
  }
}

int calculateAQI(uint16_t pm25) {
    uint16_t Clow, Chigh;
    int AQIlow, AQIhigh;

    if (pm25 <= 12) {
        Clow = 0; Chigh = 12; AQIlow = 0; AQIhigh = 50;
    } else if (pm25 <= 35) {
        Clow = 13; Chigh = 35; AQIlow = 51; AQIhigh = 100;
    } else if (pm25 <= 55) {
        Clow = 36; Chigh = 55; AQIlow = 101; AQIhigh = 150;
    } else if (pm25 <= 150) {
        Clow = 56; Chigh = 150; AQIlow = 151; AQIhigh = 200;
    } else if (pm25 <= 250) {
        Clow = 151; Chigh = 250; AQIlow = 201; AQIhigh = 300;
    } else if (pm25 <= 500) {
        Clow = 251; Chigh = 500; AQIlow = 301; AQIhigh = 500;
    } else {
        // If PM2.5 exceeds the AQI limits, return maximum AQI
        return 500;
    }

    // Calculate AQI using integer math
    int AQI = ((AQIhigh - AQIlow) * (pm25 - Clow)) / (Chigh - Clow) + AQIlow;
    return AQI;
}

boolean readPMSdata(Stream *s) {
  if (! s->available()) {
    return false;
  }

  // Read a byte at a time until we get to the special '0x42' start-byte
  if (s->peek() != 0x42) {
    s->read();
    return false;
  }

  // Now read all 32 bytes
  if (s->available() < 32) {
    return false;
  }

  uint8_t buffer[32];
  uint16_t sum = 0;
  s->readBytes(buffer, 32);

  // get checksum ready
  for (uint8_t i = 0; i < 30; i++) {
    sum += buffer[i];
  }

  // The data comes in endian'd, this solves it so it works on all platforms
  uint16_t buffer_u16[15];
  for (uint8_t i = 0; i < 15; i++) {
    buffer_u16[i] = buffer[2 + i * 2 + 1];
    buffer_u16[i] += (buffer[2 + i * 2] << 8);
  }

  // put it into a nice struct :)
  memcpy((void *)&data, (void *)buffer_u16, 30);

  if (sum != data.checksum) {
    return false;
  }
  // success!
  return true;
}

void init_pcf(void)
{
  // Set pinMode to OUTPUT
  pcf8574.pinMode(P0, OUTPUT);
  pcf8574.pinMode(P1, OUTPUT);
  pcf8574.pinMode(P2, OUTPUT);
  pcf8574.pinMode(P3, OUTPUT);

  // Set all outputs high
  pcf8574.digitalWrite(P0, HIGH);
  pcf8574.digitalWrite(P1, HIGH);
  pcf8574.digitalWrite(P2, HIGH);
  pcf8574.digitalWrite(P3, HIGH);

  pcf8574.begin();
}

void initButtons(void) {
  DDRC   &= ~((1 << DDC0) | (1 << DDC1) | (1 << DDC2));       // Set as input (Using for interupt PCINT1)
  DDRD   &= ~((1 << DDD4) | (1 << DDD5));       // Set as input (Using for interupt PCINT2)
  PORTC  |= ((1 << PORTC0) | (1 << PORTC1) | (1 << PORTC2));     // Enable pull-up resistor
  PORTD  |= ((1 << PORTD4) | (1 << PORTD5));     // Enable pull-up resistor
  // Setting Pin Change ISR for Buttons
  PCMSK1 |= ((1 << PCINT8) | (1 << PCINT9) | (1 << PCINT10));     // want pin PCINT8-10
  PCMSK2 |= ((1 << PCINT20) | (1 << PCINT21));     // want pin PCINT20-21
  PCIFR  |= ((1 << PCIF1) | (1 << PCIF2));      // clear any outstanding interrupts
  PCICR  |= ((1 << PCIE1) | (1 << PCIE2));      // enable pin change interrupts for PCINT8-10 and PCINT20-21
}

void Enable_Timer0(void) {
  TCCR0B &= ~((1 << CS00) | (1 << CS01) | (1 << CS02)) ;    // Turn OFF Timer
  // Setting Timer1 for PWM control
  TCCR0A |= (1 << WGM01);                                 // Set the Timer Mode to CTC
  TCCR0B |= (1 << CS00) | (1 << CS01) ;                   // set pre-scaler to 64 and start the timer
  OCR0A = TIM0_OVF;                                       // Set 249 as value to count to
  TIMSK0 |= (1 << OCIE0A);                                //Set the ISR COMPA vector
}

void initSegment(void) {
  //mySerial.write(DISP_OFF);
}

void dispSegment(int digit) {
  gfx->setCursor(70, 25);
  gfx->setTextColor(foreColor, bgColor);
  gfx->setTextSize(5);
  sprintf(buff, "0%dH", digit);
  gfx->print(buff);
}

void set_LED_Sleep(bool b1) {
  if (!isSleep) {
    if (b1 == true)      gfx->drawBitmap(25, 100, sleepSign, 46, 47, foreColor);
    else                gfx->drawBitmap(25, 100, sleepSign, 46, 47, bgColor);
  }
  if (b1 == true)      ledStatus |= (1 << LED_SLEEP);
  else				ledStatus &= ~(1 << LED_SLEEP);
}

void set_LED_Fan(bool b1) {
  if (!isSleep) {
    if (b1 == true) {
      gfx->drawBitmap(93, 160, fan, 58, 58, foreColor);
      gfx->drawCircle(122, 188, 31, foreColor);
      gfx->drawCircle(122, 188, 30, foreColor);
      gfx->drawCircle(122, 188, 29, foreColor);
    }
    else {
      gfx->drawBitmap(93, 160, fan, 58, 58, bgColor);
      gfx->drawCircle(122, 188, 31, bgColor);
      gfx->drawCircle(122, 188, 30, bgColor);
      gfx->drawCircle(122, 188, 29, bgColor);
    }
  }
  if (b1 == true)      ledStatus |= (1 << LED_FAN);
  else				ledStatus &= ~(1 << LED_FAN);
}

void set_LED_Auto(bool b1) {
  if (!isSleep && sysState == STATE_POWER_ON) {
    if (b1 == true)      gfx->drawBitmap(175, 95, refresh, 43, 47, foreColor);
    else                gfx->drawBitmap(175, 95, refresh, 43, 47, bgColor);
  }
  if (b1 == true)      ledStatus |= (1 << LED_AUTO_MODE);
  else				ledStatus &= ~(1 << LED_AUTO_MODE);
}

void set_LED_Speed(unsigned char uc1) {
  switch (uc1)
  {
    case 0:     // Speed : 0, OFF
      if (!isSleep) {
        set_LED_Fan(false);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, bgColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, bgColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
      }
      ledStatus &= ~((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH_DIM));
      break;
    case 1:     // Speed : 1
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, bgColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
      }
      ledStatus |= ((1 << LED_SPEED_LOW) | (1 << LED_SPEED_LOW_DIM));
      ledStatus &= ~((1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH_DIM));
      break;
    case 2:     // Speed : 2
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, bgColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
      }
      ledStatus |= (1 << LED_SPEED_LOW);
      ledStatus &= ~((1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH) | (1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH_DIM));
      break;
    case 3:     // Speed : 3
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, foreColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
      }
      ledStatus |= ((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED) | (1 << LED_SPEED_MED_DIM));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_HIGH) | (1 << LED_SPEED_HIGH_DIM));
      break;
    case 4:     // Speed : 4
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, foreColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
      }
      ledStatus |= ((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH) | (1 << LED_SPEED_HIGH_DIM));
      break;
    case 5:     // Speed : 5
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, foreColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, foreColor);
      }
      ledStatus |= ((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH) | (1 << LED_SPEED_HIGH_DIM));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM));
      break;
    case 6:     // Speed : 6
      if (!isSleep && sysState == STATE_POWER_ON) {
        set_LED_Fan(true);
        gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
        gfx->drawBitmap(92, 100, wifi2, 56, 21, foreColor);
        gfx->drawBitmap(82, 80, wifi3, 76, 25, foreColor);
      }
      ledStatus |= ((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH_DIM));
      break;
    default:    // Speed : 0, Unknown input, OFF
      set_LED_Fan(false);
      gfx->drawBitmap(103, 120, wifi1, 35, 17, bgColor);
      gfx->drawBitmap(92, 100, wifi2, 56, 21, bgColor);
      gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
      ledStatus &= ~((1 << LED_SPEED_LOW) | (1 << LED_SPEED_MED) | (1 << LED_SPEED_HIGH));
      ledStatus &= ~((1 << LED_SPEED_LOW_DIM) | (1 << LED_SPEED_MED_DIM) | (1 << LED_SPEED_HIGH_DIM));
      break;
  }
}

void LEDs_Restore(void)
{
  set_LED_Fan((bool)(ledStatus & NUM_LED_FAN));
  set_LED_Auto((bool)(ledStatus & NUM_LED_AUTO));
  if (((ledStatus & NUM_LED_SPEED_LOW) == NUM_LED_SPEED_LOW) && ((ledStatus & NUM_LED_SPEED_LOW_DIM) == NUM_LED_SPEED_LOW_DIM))
    gfx->drawBitmap(103, 120, wifi1, 35, 17, dimColor);
  else if (((ledStatus & NUM_LED_SPEED_LOW) == NUM_LED_SPEED_LOW) && ((ledStatus & NUM_LED_SPEED_LOW_DIM) == 0))
    gfx->drawBitmap(103, 120, wifi1, 35, 17, foreColor);
  else if (((ledStatus & NUM_LED_SPEED_LOW) == 0) && ((ledStatus & NUM_LED_SPEED_LOW_DIM) == 0))
    gfx->drawBitmap(103, 120, wifi1, 35, 17, bgColor);

  if (((ledStatus & NUM_LED_SPEED_MED) == NUM_LED_SPEED_MED) && ((ledStatus & NUM_LED_SPEED_MED_DIM) == NUM_LED_SPEED_MED_DIM))
    gfx->drawBitmap(92, 100, wifi2, 56, 21, dimColor);
  else if (((ledStatus & NUM_LED_SPEED_MED) == NUM_LED_SPEED_MED) && ((ledStatus & NUM_LED_SPEED_MED_DIM) == 0))
    gfx->drawBitmap(92, 100, wifi2, 56, 21, foreColor);
  else if (((ledStatus & NUM_LED_SPEED_MED) == 0) && ((ledStatus & NUM_LED_SPEED_MED_DIM) == 0))
    gfx->drawBitmap(92, 100, wifi2, 56, 21, bgColor);

  if (((ledStatus & NUM_LED_SPEED_HIGH) == NUM_LED_SPEED_HIGH) && ((ledStatus & NUM_LED_SPEED_HIGH_DIM) == NUM_LED_SPEED_HIGH_DIM))
    gfx->drawBitmap(82, 80, wifi3, 76, 25, dimColor);
  else if (((ledStatus & NUM_LED_SPEED_HIGH) == NUM_LED_SPEED_HIGH) && ((ledStatus & NUM_LED_SPEED_HIGH_DIM) == 0))
    gfx->drawBitmap(82, 80, wifi3, 76, 25, foreColor);
  else if (((ledStatus & NUM_LED_SPEED_HIGH) == 0) && ((ledStatus & NUM_LED_SPEED_HIGH_DIM) == 0))
    gfx->drawBitmap(82, 80, wifi3, 76, 25, bgColor);
}

uint16_t createRGB(int r, int g, int b)
{
  return ((r & 0xff) << 16) + ((g & 0xff) << 8) + (b & 0xff);
}

void playMelody(void) {
  int numTones = 10;
  int tones[] = {261, 277, 294, 311, 330, 349, 370, 392, 415, 440};
  //            mid C  C#   D    D#   E    F    F#   G    G#   A

  for (int i = numTones; i > 0; i--)
  {
    tone(PIN_BUZZ, tones[i]);
    delay(150);
  }
  delay(300);
  noTone(PIN_BUZZ);
}

void play_device_on(void)
{
  pcf8574.digitalWrite(P0, LOW);
  delay(MUSIC_PLAY_TIME);
  pcf8574.digitalWrite(P0, HIGH);
}

void play_device_off(void)
{
  pcf8574.digitalWrite(P1, LOW);
  delay(MUSIC_PLAY_TIME);
  pcf8574.digitalWrite(P1, HIGH);
}

void play_menu_up(void)
{
  pcf8574.digitalWrite(P2, LOW);
  delay(MUSIC_PLAY_TIME);
  pcf8574.digitalWrite(P2, HIGH);
}

void play_menu_down(void)
{
  pcf8574.digitalWrite(P3, LOW);
  delay(MUSIC_PLAY_TIME);
  pcf8574.digitalWrite(P3, HIGH);
}
